[
  {
    "id": "e3f3292a-97ef-466a-971f-fe770e28946d",
    "title": "tailwind.config.js",
    "code": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\"./src/**/*.{html,js,jsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [\n    require(\"@tailwindcss/typography\"),\n    require(\"@tailwindcss/forms\"),\n    require(\"@tailwindcss/aspect-ratio\")\n  ],\n};\n",
    "language": "javascript",
    "description": "Description tailwind.config.js",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-06T16:47:11.044Z",
    "updatedAt": "2025-03-06T16:47:26.629Z"
  },
  {
    "id": "483171e5-304d-4d7a-864e-3e6bcae65406",
    "title": "webpack.main.config.js",
    "code": "module.exports = {\n  /**\n   * This is the main entry point for your application, it's the first file\n   * that runs in the main process.\n   */\n  entry: './src/main.js',\n  // Put your normal webpack config below here\n  module: {\n    rules: require('./webpack.rules'),\n  },\n};\n",
    "language": "javascript",
    "description": "Description webpack.main.config.js",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-06T16:48:03.433Z",
    "updatedAt": "2025-03-06T16:48:03.433Z"
  },
  {
    "id": "2201ec7c-e9bf-4de6-9b90-3a762da0d20c",
    "title": "App.jsx",
    "code": "import React, { useState, useEffect } from 'react';\nimport { AppProvider, useAppContext } from './context/AppContext';\nimport Sidebar from './components/Sidebar';\nimport SnippetList from './components/SnippetList';\nimport SnippetDetail from './components/SnippetDetail';\nimport SnippetForm from './components/SnippetForm';\nimport InfoPage from './components/InfoPage';\nimport SplashScreen from './components/SplashScreen';\n\nconst AppContent = () => {\n  const { state, deleteSnippet } = useAppContext(); \n  const [selectedTag, setSelectedTag] = useState(null);\n  const [selectedSnippetId, setSelectedSnippetId] = useState(null);\n  const [showSnippetForm, setShowSnippetForm] = useState(false);\n  const [editingSnippet, setEditingSnippet] = useState(undefined);\n  const [showInfoPage, setShowInfoPage] = useState(false);\n  const [splashFinished, setSplashFinished] = useState(false);\n\n  // R√©cup√©rer le snippet s√©lectionn√© directement depuis le state pour avoir toujours la version √† jour\n  const selectedSnippet = selectedSnippetId \n    ? state.snippets.find(s => s.id === selectedSnippetId) \n    : null;\n\n  const handleNewSnippet = (prefilledValues = undefined) => {\n    if (prefilledValues) {\n      setEditingSnippet({\n        title: prefilledValues.title || '',\n        code: prefilledValues.code || '',\n        description: prefilledValues.description || '',\n        language: prefilledValues.language || 'text',\n        tags: prefilledValues.tags || [] \n      });\n    } else {\n      setEditingSnippet(undefined);\n    }\n    setShowSnippetForm(true);\n    setShowInfoPage(false);\n  };\n\n  const handleEditSnippet = (snippet) => {\n    setEditingSnippet(snippet);\n    setShowSnippetForm(true);\n    setShowInfoPage(false);\n  };\n\n  const handleCloseForm = () => {\n    setShowSnippetForm(false);\n    setEditingSnippet(undefined);\n  };\n\n  const handleSaveForm = () => {\n    setShowSnippetForm(false);\n    \n    // Si nous √©tions en train d'√©diter un snippet, assurons-nous qu'il reste s√©lectionn√©\n    if (editingSnippet && editingSnippet.id) {\n      setSelectedSnippetId(editingSnippet.id);\n    }\n    \n    setEditingSnippet(undefined);\n  };\n\n  const handleSelectTag = (tag) => {\n    setSelectedTag(tag);\n    setSelectedSnippetId(null);\n    setShowInfoPage(false);\n  };\n\n  const handleViewSnippet = (snippet) => {\n    setSelectedSnippetId(snippet.id);\n    setShowSnippetForm(false);\n    setShowInfoPage(false);\n  };\n\n  const handleDeleteSnippet = (id) => {\n    deleteSnippet(id);\n    if (selectedSnippetId === id) {\n      setSelectedSnippetId(null);\n    }\n  };\n\n  const handleShowInfo = () => {\n    setShowInfoPage(true);\n  };\n\n  const handleGoBack = () => {\n    setShowInfoPage(false);\n  };\n  \n  const handleSplashFinish = () => {\n    setSplashFinished(true);\n  };\n\n  if (!splashFinished) {\n    return <SplashScreen onFinish={handleSplashFinish} />;\n  }\n\n  return (\n    <div className={`flex h-screen overflow-hidden ${state.theme === 'dark' ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`}>\n      <Sidebar \n        onNewSnippet={handleNewSnippet} \n        onSelectTag={handleSelectTag}\n        selectedTag={selectedTag}\n        onShowInfo={handleShowInfo}\n      />\n      \n      {showInfoPage ? (\n        <div className=\"flex-1 overflow-hidden\">\n          <InfoPage onGoBack={handleGoBack} />\n        </div>\n      ) : (\n        <>\n          <SnippetList \n            selectedTag={selectedTag}\n            onEditSnippet={handleEditSnippet}\n            onViewSnippet={handleViewSnippet}\n            onDeleteSnippet={handleDeleteSnippet}\n            selectedSnippetId={selectedSnippetId}\n          />\n          \n          {selectedSnippet ? (\n            <SnippetDetail snippet={selectedSnippet} />\n          ) : (\n            <div className={`flex-1 flex flex-col items-center justify-center ${state.theme === 'dark' ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`}>\n              <div className=\"text-6xl mb-4 opacity-20\">üìù</div>\n              <h2 className=\"text-xl font-semibold mb-2\">No Snippet Selected</h2>\n              <p className={`${state.theme === 'dark' ? 'text-gray-400' : 'text-gray-500'} text-center`}>\n                Select a snippet from the list<br />or create a new one\n              </p>\n            </div>\n          )}\n          \n          {showSnippetForm && (\n            <SnippetForm \n              snippet={editingSnippet} \n              onClose={handleCloseForm}\n              onSave={handleSaveForm}\n            />\n          )}\n        </>\n      )}\n    </div>\n  );\n};\n\nfunction App() {\n  return (\n    <AppProvider>\n      <AppContent />\n    </AppProvider>\n  );\n}\n\nexport default App;",
    "language": "jsx",
    "description": "Description App.jsx",
    "tags": [
      "jsx",
      "Js",
      "typescrip"
    ],
    "createdAt": "2025-03-06T16:48:58.453Z",
    "updatedAt": "2025-03-06T17:34:58.655Z"
  },
  {
    "id": "5b485b27-54b7-4fe1-8db5-49fb7e5a9bee",
    "title": "index.css",
    "code": "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n\n@keyframes fadeIn {\n    0% {\n      opacity: 0;\n      transform: translateY(5px) scale(0.95);\n    }\n    100% {\n      opacity: 1;\n      transform: translateY(0) scale(1);\n    }\n  }\n  \n  @keyframes gentleSpin {\n    0% {\n      transform: rotate(0deg) scale(1);\n    }\n    50% {\n      transform: rotate(180deg) scale(1.05);\n    }\n    100% {\n      transform: rotate(360deg) scale(1);\n    }\n  }\n  \n  @keyframes pulse {\n    0% {\n      opacity: 1;\n      transform: scale(1);\n    }\n    50% {\n      opacity: 0.85;\n      transform: scale(0.98);\n    }\n    100% {\n      opacity: 1;\n      transform: scale(1);\n    }\n  }\n  \n  @keyframes gradientFlow {\n    0% {\n      background-position: 0% 50%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 50%;\n    }\n  }\n  \n  @keyframes shimmer {\n    0% {\n      background-position: -200% 50%;\n    }\n    100% {\n      background-position: 200% 50%;\n    }\n  }\n  \n  .transition-all {\n    transition-duration: 1000ms;\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  }",
    "language": "css",
    "description": "Description index.css",
    "tags": [
      "css"
    ],
    "createdAt": "2025-03-06T16:49:53.726Z",
    "updatedAt": "2025-03-06T17:03:08.455Z"
  },
  {
    "id": "7467d1a6-5cb0-46f6-baa9-09b9249f86a0",
    "title": "index.html",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Code Wallet</title>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.jsx\"></script>\n</body>\n</html>",
    "language": "html",
    "description": "Description index.html",
    "tags": [
      "html"
    ],
    "createdAt": "2025-03-06T16:50:56.292Z",
    "updatedAt": "2025-03-06T17:21:15.811Z"
  },
  {
    "id": "88608255-7ac5-4134-944a-712e0baf835f",
    "title": "main.js",
    "code": "const { app, BrowserWindow, ipcMain } = require('electron');\nconst path = require('path');\nconst fs = require('fs');\n\n// √âvite les probl√®mes de d√©marrage sur Windows\nif (require('electron-squirrel-startup')) {\n  app.quit();\n}\n\n// D√©terminer si nous sommes en d√©veloppement ou en production\nconst isDev = process.env.NODE_ENV === 'development' || !app.isPackaged;\n\n// D√©tecter automatiquement la racine du projet\nlet STORAGE_PATH;\n\nif (isDev) {\n  // En d√©veloppement, utiliser le r√©pertoire de travail actuel\n  STORAGE_PATH = process.cwd(); // Obtient le r√©pertoire de travail actuel\n  console.log('Chemin de stockage (dev):', STORAGE_PATH);\n} else {\n  // En production, utiliser un dossier dans les donn√©es utilisateur\n  STORAGE_PATH = path.join(app.getPath('userData'), 'data');\n  \n  // S'assurer que le dossier existe\n  if (!fs.existsSync(STORAGE_PATH)) {\n    fs.mkdirSync(STORAGE_PATH, { recursive: true });\n  }\n  console.log('Chemin de stockage (prod):', STORAGE_PATH);\n}\n\n// Chemins de fichiers pour le stockage\nconst SNIPPETS_FILE = path.join(STORAGE_PATH, 'snippets.json');\nconst TAGS_FILE = path.join(STORAGE_PATH, 'tags.json');\n\nconsole.log('Fichier snippets sera √†:', SNIPPETS_FILE);\nconsole.log('Fichier tags sera √†:', TAGS_FILE);\n\n// V√©rifier/cr√©er les fichiers lors du d√©marrage\ntry {\n  if (!fs.existsSync(SNIPPETS_FILE)) {\n    fs.writeFileSync(SNIPPETS_FILE, JSON.stringify([]));\n    console.log('Fichier snippets.json cr√©√© avec succ√®s');\n  }\n  if (!fs.existsSync(TAGS_FILE)) {\n    fs.writeFileSync(TAGS_FILE, JSON.stringify([]));\n    console.log('Fichier tags.json cr√©√© avec succ√®s');\n  }\n} catch (error) {\n  console.error('Erreur lors de la cr√©ation des fichiers JSON:', error);\n}\n\n// Variable globale pour la fen√™tre principale\nlet mainWindow = null;\n\n// Cr√©er la fen√™tre principale\nconst createWindow = () => {\n  // Cr√©er la fen√™tre principale\n  mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,\n      contextIsolation: true,\n      nodeIntegration: false,\n    },\n    autoHideMenuBar: true,\n  });\n\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\n\n\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n  });\n};\n\n// Configurer les gestionnaires IPC\n\nfunction setupIpcHandlers() {\n  // Charger les snippets\n  ipcMain.handle('load-snippets', () => {\n    try {\n      if (!fs.existsSync(SNIPPETS_FILE)) {\n        fs.writeFileSync(SNIPPETS_FILE, JSON.stringify([]));\n        return [];\n      }\n      const data = fs.readFileSync(SNIPPETS_FILE, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error('Error loading snippets:', error);\n      return [];\n    }\n  });\n\n  // Sauvegarder les snippets\n  ipcMain.handle('save-snippets', (_, snippets) => {\n    try {\n      fs.writeFileSync(SNIPPETS_FILE, JSON.stringify(snippets, null, 2));\n      return true;\n    } catch (error) {\n      console.error('Error saving snippets:', error);\n      return false;\n    }\n  });\n\n  // Charger les tags\n  ipcMain.handle('load-tags', () => {\n    try {\n      if (!fs.existsSync(TAGS_FILE)) {\n        fs.writeFileSync(TAGS_FILE, JSON.stringify([]));\n        return [];\n      }\n      const data = fs.readFileSync(TAGS_FILE, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error('Error loading tags:', error);\n      return [];\n    }\n  });\n\n  // Sauvegarder les tags\n  ipcMain.handle('save-tags', (_, tags) => {\n    try {\n      fs.writeFileSync(TAGS_FILE, JSON.stringify(tags, null, 2));\n      return true;\n    } catch (error) {\n      console.error('Error saving tags:', error);\n      return false;\n    }\n  });\n  \n  // Ajouter un handler pour obtenir le chemin de stockage\n  ipcMain.handle('get-storage-path', () => {\n    return STORAGE_PATH;\n  });\n}\n\n// Initialiser l'application\napp.whenReady().then(() => {\n  setupIpcHandlers();\n  createWindow();\n\n  app.on('activate', () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\n\n// Gestion de la fermeture de l'application\napp.on('window-all-closed', () => {\n  // Nettoyer correctement la fen√™tre\n  if (mainWindow) {\n    if (!mainWindow.isDestroyed()) {\n      mainWindow.webContents.closeDevTools();\n      mainWindow.removeAllListeners();\n      mainWindow.close();\n    }\n    mainWindow = null;\n  }\n\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n\n// Gestion des √©v√©nements avant la fermeture\napp.on('before-quit', () => {\n  if (mainWindow && !mainWindow.isDestroyed()) {\n    mainWindow.removeAllListeners();\n    mainWindow.destroy();\n  }\n});\n\n// Gestion des erreurs non captur√©es\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  \n  // Fermeture propre de l'application en cas d'erreur\n  if (mainWindow) {\n    mainWindow.close();\n  }\n  app.quit();\n});",
    "language": "javascript",
    "description": "Description main.js",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-06T16:52:19.028Z",
    "updatedAt": "2025-03-06T16:52:19.028Z"
  },
  {
    "id": "bc842562-bae6-4642-bc81-0182c9d9e763",
    "title": "snippets.json",
    "code": "[\n  {\n    \"id\": \"e3f3292a-97ef-466a-971f-fe770e28946d\",\n    \"title\": \"tailwind.config.js\",\n    \"code\": \"/** @type {import('tailwindcss').Config} */\\nmodule.exports = {\\n  content: [\\\"./src/**/*.{html,js,jsx}\\\"],\\n  theme: {\\n    extend: {},\\n  },\\n  plugins: [\\n    require(\\\"@tailwindcss/typography\\\"),\\n    require(\\\"@tailwindcss/forms\\\"),\\n    require(\\\"@tailwindcss/aspect-ratio\\\")\\n  ],\\n};\\n\",\n    \"language\": \"javascript\",\n    \"description\": \"Description tailwind.config.js\",\n    \"tags\": [\n      \"Js\"\n    ],\n    \"createdAt\": \"2025-03-06T16:47:11.044Z\",\n    \"updatedAt\": \"2025-03-06T16:47:26.629Z\"\n  },\n  {\n    \"id\": \"483171e5-304d-4d7a-864e-3e6bcae65406\",\n    \"title\": \"webpack.main.config.js\",\n    \"code\": \"module.exports = {\\n  /**\\n   * This is the main entry point for your application, it's the first file\\n   * that runs in the main process.\\n   */\\n  entry: './src/main.js',\\n  // Put your normal webpack config below here\\n  module: {\\n    rules: require('./webpack.rules'),\\n  },\\n};\\n\",\n    \"language\": \"javascript\",\n    \"description\": \"Description webpack.main.config.js\",\n    \"tags\": [\n      \"Js\"\n    ],\n    \"createdAt\": \"2025-03-06T16:48:03.433Z\",\n    \"updatedAt\": \"2025-03-06T16:48:03.433Z\"\n  },\n  {\n    \"id\": \"2201ec7c-e9bf-4de6-9b90-3a762da0d20c\",\n    \"title\": \"App.jsx\",\n    \"code\": \"import React, { useState, useEffect } from 'react';\\nimport { AppProvider, useAppContext } from './context/AppContext';\\nimport Sidebar from './components/Sidebar';\\nimport SnippetList from './components/SnippetList';\\nimport SnippetDetail from './components/SnippetDetail';\\nimport SnippetForm from './components/SnippetForm';\\nimport InfoPage from './components/InfoPage';\\nimport SplashScreen from './components/SplashScreen';\\n\\nconst AppContent = () => {\\n  const { state, deleteSnippet } = useAppContext(); \\n  const [selectedTag, setSelectedTag] = useState(null);\\n  const [selectedSnippetId, setSelectedSnippetId] = useState(null);\\n  const [showSnippetForm, setShowSnippetForm] = useState(false);\\n  const [editingSnippet, setEditingSnippet] = useState(undefined);\\n  const [showInfoPage, setShowInfoPage] = useState(false);\\n  const [splashFinished, setSplashFinished] = useState(false);\\n\\n  // R√©cup√©rer le snippet s√©lectionn√© directement depuis le state pour avoir toujours la version √† jour\\n  const selectedSnippet = selectedSnippetId \\n    ? state.snippets.find(s => s.id === selectedSnippetId) \\n    : null;\\n\\n  const handleNewSnippet = (prefilledValues = undefined) => {\\n    if (prefilledValues) {\\n      setEditingSnippet({\\n        title: prefilledValues.title || '',\\n        code: prefilledValues.code || '',\\n        description: prefilledValues.description || '',\\n        language: prefilledValues.language || 'text',\\n        tags: prefilledValues.tags || [] \\n      });\\n    } else {\\n      setEditingSnippet(undefined);\\n    }\\n    setShowSnippetForm(true);\\n    setShowInfoPage(false);\\n  };\\n\\n  const handleEditSnippet = (snippet) => {\\n    setEditingSnippet(snippet);\\n    setShowSnippetForm(true);\\n    setShowInfoPage(false);\\n  };\\n\\n  const handleCloseForm = () => {\\n    setShowSnippetForm(false);\\n    setEditingSnippet(undefined);\\n  };\\n\\n  const handleSaveForm = () => {\\n    setShowSnippetForm(false);\\n    \\n    // Si nous √©tions en train d'√©diter un snippet, assurons-nous qu'il reste s√©lectionn√©\\n    if (editingSnippet && editingSnippet.id) {\\n      setSelectedSnippetId(editingSnippet.id);\\n    }\\n    \\n    setEditingSnippet(undefined);\\n  };\\n\\n  const handleSelectTag = (tag) => {\\n    setSelectedTag(tag);\\n    setSelectedSnippetId(null);\\n    setShowInfoPage(false);\\n  };\\n\\n  const handleViewSnippet = (snippet) => {\\n    setSelectedSnippetId(snippet.id);\\n    setShowSnippetForm(false);\\n    setShowInfoPage(false);\\n  };\\n\\n  const handleDeleteSnippet = (id) => {\\n    deleteSnippet(id);\\n    if (selectedSnippetId === id) {\\n      setSelectedSnippetId(null);\\n    }\\n  };\\n\\n  const handleShowInfo = () => {\\n    setShowInfoPage(true);\\n  };\\n\\n  const handleGoBack = () => {\\n    setShowInfoPage(false);\\n  };\\n  \\n  const handleSplashFinish = () => {\\n    setSplashFinished(true);\\n  };\\n\\n  if (!splashFinished) {\\n    return <SplashScreen onFinish={handleSplashFinish} />;\\n  }\\n\\n  return (\\n    <div className={`flex h-screen overflow-hidden ${state.theme === 'dark' ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`}>\\n      <Sidebar \\n        onNewSnippet={handleNewSnippet} \\n        onSelectTag={handleSelectTag}\\n        selectedTag={selectedTag}\\n        onShowInfo={handleShowInfo}\\n      />\\n      \\n      {showInfoPage ? (\\n        <div className=\\\"flex-1 overflow-hidden\\\">\\n          <InfoPage onGoBack={handleGoBack} />\\n        </div>\\n      ) : (\\n        <>\\n          <SnippetList \\n            selectedTag={selectedTag}\\n            onEditSnippet={handleEditSnippet}\\n            onViewSnippet={handleViewSnippet}\\n            onDeleteSnippet={handleDeleteSnippet}\\n            selectedSnippetId={selectedSnippetId}\\n          />\\n          \\n          {selectedSnippet ? (\\n            <SnippetDetail snippet={selectedSnippet} />\\n          ) : (\\n            <div className={`flex-1 flex flex-col items-center justify-center ${state.theme === 'dark' ? 'bg-gray-900 text-white' : 'bg-white text-gray-800'}`}>\\n              <div className=\\\"text-6xl mb-4 opacity-20\\\">üìù</div>\\n              <h2 className=\\\"text-xl font-semibold mb-2\\\">No Snippet Selected</h2>\\n              <p className={`${state.theme === 'dark' ? 'text-gray-400' : 'text-gray-500'} text-center`}>\\n                Select a snippet from the list<br />or create a new one\\n              </p>\\n            </div>\\n          )}\\n          \\n          {showSnippetForm && (\\n            <SnippetForm \\n              snippet={editingSnippet} \\n              onClose={handleCloseForm}\\n              onSave={handleSaveForm}\\n            />\\n          )}\\n        </>\\n      )}\\n    </div>\\n  );\\n};\\n\\nfunction App() {\\n  return (\\n    <AppProvider>\\n      <AppContent />\\n    </AppProvider>\\n  );\\n}\\n\\nexport default App;\",\n    \"language\": \"jsx\",\n    \"description\": \"Description App.jsx\",\n    \"tags\": [\n      \"jsx\"\n    ],\n    \"createdAt\": \"2025-03-06T16:48:58.453Z\",\n    \"updatedAt\": \"2025-03-06T16:48:58.453Z\"\n  },\n  {\n    \"id\": \"5b485b27-54b7-4fe1-8db5-49fb7e5a9bee\",\n    \"title\": \"index.css\",\n    \"code\": \"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n\\n@keyframes fadeIn {\\n    0% {\\n      opacity: 0;\\n      transform: translateY(5px) scale(0.95);\\n    }\\n    100% {\\n      opacity: 1;\\n      transform: translateY(0) scale(1);\\n    }\\n  }\\n  \\n  @keyframes gentleSpin {\\n    0% {\\n      transform: rotate(0deg) scale(1);\\n    }\\n    50% {\\n      transform: rotate(180deg) scale(1.05);\\n    }\\n    100% {\\n      transform: rotate(360deg) scale(1);\\n    }\\n  }\\n  \\n  @keyframes pulse {\\n    0% {\\n      opacity: 1;\\n      transform: scale(1);\\n    }\\n    50% {\\n      opacity: 0.85;\\n      transform: scale(0.98);\\n    }\\n    100% {\\n      opacity: 1;\\n      transform: scale(1);\\n    }\\n  }\\n  \\n  @keyframes gradientFlow {\\n    0% {\\n      background-position: 0% 50%;\\n    }\\n    50% {\\n      background-position: 100% 50%;\\n    }\\n    100% {\\n      background-position: 0% 50%;\\n    }\\n  }\\n  \\n  @keyframes shimmer {\\n    0% {\\n      background-position: -200% 50%;\\n    }\\n    100% {\\n      background-position: 200% 50%;\\n    }\\n  }\\n  \\n  .transition-all {\\n    transition-duration: 1000ms;\\n    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  }\",\n    \"language\": \"css\",\n    \"description\": \"Description index.css\",\n    \"tags\": [\n      \"css\"\n    ],\n    \"createdAt\": \"2025-03-06T16:49:53.726Z\",\n    \"updatedAt\": \"2025-03-06T17:03:08.455Z\"\n  },\n  {\n    \"id\": \"7467d1a6-5cb0-46f6-baa9-09b9249f86a0\",\n    \"title\": \"index.html\",\n    \"code\": \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>Code Wallet</title>\\n</head>\\n<body>\\n    <div id=\\\"root\\\"></div>\\n    <script type=\\\"module\\\" src=\\\"/src/main.jsx\\\"></script>\\n</body>\\n</html>\",\n    \"language\": \"html\",\n    \"description\": \"Description index.html\",\n    \"tags\": [\n      \"html\"\n    ],\n    \"createdAt\": \"2025-03-06T16:50:56.292Z\",\n    \"updatedAt\": \"2025-03-06T16:50:56.292Z\"\n  },\n  {\n    \"id\": \"88608255-7ac5-4134-944a-712e0baf835f\",\n    \"title\": \"main.js\",\n    \"code\": \"const { app, BrowserWindow, ipcMain } = require('electron');\\nconst path = require('path');\\nconst fs = require('fs');\\n\\n// √âvite les probl√®mes de d√©marrage sur Windows\\nif (require('electron-squirrel-startup')) {\\n  app.quit();\\n}\\n\\n// D√©terminer si nous sommes en d√©veloppement ou en production\\nconst isDev = process.env.NODE_ENV === 'development' || !app.isPackaged;\\n\\n// D√©tecter automatiquement la racine du projet\\nlet STORAGE_PATH;\\n\\nif (isDev) {\\n  // En d√©veloppement, utiliser le r√©pertoire de travail actuel\\n  STORAGE_PATH = process.cwd(); // Obtient le r√©pertoire de travail actuel\\n  console.log('Chemin de stockage (dev):', STORAGE_PATH);\\n} else {\\n  // En production, utiliser un dossier dans les donn√©es utilisateur\\n  STORAGE_PATH = path.join(app.getPath('userData'), 'data');\\n  \\n  // S'assurer que le dossier existe\\n  if (!fs.existsSync(STORAGE_PATH)) {\\n    fs.mkdirSync(STORAGE_PATH, { recursive: true });\\n  }\\n  console.log('Chemin de stockage (prod):', STORAGE_PATH);\\n}\\n\\n// Chemins de fichiers pour le stockage\\nconst SNIPPETS_FILE = path.join(STORAGE_PATH, 'snippets.json');\\nconst TAGS_FILE = path.join(STORAGE_PATH, 'tags.json');\\n\\nconsole.log('Fichier snippets sera √†:', SNIPPETS_FILE);\\nconsole.log('Fichier tags sera √†:', TAGS_FILE);\\n\\n// V√©rifier/cr√©er les fichiers lors du d√©marrage\\ntry {\\n  if (!fs.existsSync(SNIPPETS_FILE)) {\\n    fs.writeFileSync(SNIPPETS_FILE, JSON.stringify([]));\\n    console.log('Fichier snippets.json cr√©√© avec succ√®s');\\n  }\\n  if (!fs.existsSync(TAGS_FILE)) {\\n    fs.writeFileSync(TAGS_FILE, JSON.stringify([]));\\n    console.log('Fichier tags.json cr√©√© avec succ√®s');\\n  }\\n} catch (error) {\\n  console.error('Erreur lors de la cr√©ation des fichiers JSON:', error);\\n}\\n\\n// Variable globale pour la fen√™tre principale\\nlet mainWindow = null;\\n\\n// Cr√©er la fen√™tre principale\\nconst createWindow = () => {\\n  // Cr√©er la fen√™tre principale\\n  mainWindow = new BrowserWindow({\\n    width: 1200,\\n    height: 800,\\n    webPreferences: {\\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,\\n      contextIsolation: true,\\n      nodeIntegration: false,\\n    },\\n    autoHideMenuBar: true,\\n  });\\n\\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\\n\\n\\n  mainWindow.on('closed', () => {\\n    mainWindow = null;\\n  });\\n};\\n\\n// Configurer les gestionnaires IPC\\n\\nfunction setupIpcHandlers() {\\n  // Charger les snippets\\n  ipcMain.handle('load-snippets', () => {\\n    try {\\n      if (!fs.existsSync(SNIPPETS_FILE)) {\\n        fs.writeFileSync(SNIPPETS_FILE, JSON.stringify([]));\\n        return [];\\n      }\\n      const data = fs.readFileSync(SNIPPETS_FILE, 'utf8');\\n      return JSON.parse(data);\\n    } catch (error) {\\n      console.error('Error loading snippets:', error);\\n      return [];\\n    }\\n  });\\n\\n  // Sauvegarder les snippets\\n  ipcMain.handle('save-snippets', (_, snippets) => {\\n    try {\\n      fs.writeFileSync(SNIPPETS_FILE, JSON.stringify(snippets, null, 2));\\n      return true;\\n    } catch (error) {\\n      console.error('Error saving snippets:', error);\\n      return false;\\n    }\\n  });\\n\\n  // Charger les tags\\n  ipcMain.handle('load-tags', () => {\\n    try {\\n      if (!fs.existsSync(TAGS_FILE)) {\\n        fs.writeFileSync(TAGS_FILE, JSON.stringify([]));\\n        return [];\\n      }\\n      const data = fs.readFileSync(TAGS_FILE, 'utf8');\\n      return JSON.parse(data);\\n    } catch (error) {\\n      console.error('Error loading tags:', error);\\n      return [];\\n    }\\n  });\\n\\n  // Sauvegarder les tags\\n  ipcMain.handle('save-tags', (_, tags) => {\\n    try {\\n      fs.writeFileSync(TAGS_FILE, JSON.stringify(tags, null, 2));\\n      return true;\\n    } catch (error) {\\n      console.error('Error saving tags:', error);\\n      return false;\\n    }\\n  });\\n  \\n  // Ajouter un handler pour obtenir le chemin de stockage\\n  ipcMain.handle('get-storage-path', () => {\\n    return STORAGE_PATH;\\n  });\\n}\\n\\n// Initialiser l'application\\napp.whenReady().then(() => {\\n  setupIpcHandlers();\\n  createWindow();\\n\\n  app.on('activate', () => {\\n    if (BrowserWindow.getAllWindows().length === 0) {\\n      createWindow();\\n    }\\n  });\\n});\\n\\n// Gestion de la fermeture de l'application\\napp.on('window-all-closed', () => {\\n  // Nettoyer correctement la fen√™tre\\n  if (mainWindow) {\\n    if (!mainWindow.isDestroyed()) {\\n      mainWindow.webContents.closeDevTools();\\n      mainWindow.removeAllListeners();\\n      mainWindow.close();\\n    }\\n    mainWindow = null;\\n  }\\n\\n  if (process.platform !== 'darwin') {\\n    app.quit();\\n  }\\n});\\n\\n// Gestion des √©v√©nements avant la fermeture\\napp.on('before-quit', () => {\\n  if (mainWindow && !mainWindow.isDestroyed()) {\\n    mainWindow.removeAllListeners();\\n    mainWindow.destroy();\\n  }\\n});\\n\\n// Gestion des erreurs non captur√©es\\nprocess.on('uncaughtException', (error) => {\\n  console.error('Uncaught Exception:', error);\\n  \\n  // Fermeture propre de l'application en cas d'erreur\\n  if (mainWindow) {\\n    mainWindow.close();\\n  }\\n  app.quit();\\n});\",\n    \"language\": \"javascript\",\n    \"description\": \"Description main.js\",\n    \"tags\": [\n      \"Js\"\n    ],\n    \"createdAt\": \"2025-03-06T16:52:19.028Z\",\n    \"updatedAt\": \"2025-03-06T16:52:19.028Z\"\n  }\n]",
    "language": "json",
    "description": "Description snippets.json",
    "tags": [
      "Js",
      "arnauld"
    ],
    "createdAt": "2025-03-06T17:10:27.706Z",
    "updatedAt": "2025-03-13T16:55:12.198Z"
  },
  {
    "id": "5bd23aa5-17ed-4a20-9fd2-c96ac79d48c2",
    "title": "preload.js",
    "code": "const { contextBridge, ipcRenderer } = require('electron');\n\ncontextBridge.exposeInMainWorld('api', {\n\n  loadSnippets: () => ipcRenderer.invoke('load-snippets'),\n  saveSnippets: (snippets) => ipcRenderer.invoke('save-snippets', snippets),\n  loadTags: () => ipcRenderer.invoke('load-tags'),\n  saveTags: (tags) => ipcRenderer.invoke('save-tags', tags),\n  \n});",
    "language": "javascript",
    "description": "Description preload.js",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-06T17:41:10.931Z",
    "updatedAt": "2025-03-06T17:41:10.931Z"
  },
  {
    "id": "946a4e89-9b8a-4bb1-8fa0-f20639f8dfdd",
    "title": "bot trading",
    "code": "import websocket\nimport json\nimport time\nimport datetime\nimport threading\nimport numpy as np\nimport pandas as pd\nimport ta\nfrom collections import deque\nimport rel\n\n# Configuration\nAPP_ID = \"1089\" \nAPI_TOKEN = \"xIEK9p4hVgl5XDC\"\nTOKEN = API_TOKEN  # Ajout de cette ligne\nSYMBOL = \"R_100\"\n\n# Param√®tres de la strat√©gie\nRSI_PERIOD = 14\nBOLLINGER_PERIOD = 20\nBOLLINGER_STD = 2\nATR_PERIOD = 5\nRISK_PER_TRADE = 0.02  # 2% du capital\nREWARD_RISK_RATIO_HIGH_VOL = 2.0  # Pour ATR > 3\nREWARD_RISK_RATIO_LOW_VOL = 1.5   # Pour ATR < 3\nMIN_TICK_RATE = 0.4  # Ajust√© pour fonctionner avec 1 tick toutes les 2-3 secondes\n\n# Variables pour stocker les donn√©es\nticks_data = []\ntimestamps = []\ntick_rates = []  # Nombre de ticks par seconde\nvolume_data = []  # Volume fictif bas√© sur les mouvements de prix\naccount_balance = None\naccount_currency = None\ncurrent_trade = None\ntrade_history = []\npositions = []\nactive_contracts = {}  # Pour stocker les contrats actifs\nlast_order_time = None  # Pour limiter la fr√©quence des trades\n\n# Files pour m√©moriser les derniers ticks et leur timestamp\nlast_ticks = deque(maxlen=50)  # Garder plus de ticks pour les calculs\nlast_tick_times = deque(maxlen=50)\ntick_volume = deque(maxlen=20)  # Pour estimer le volume bas√© sur les mouvements de prix\n\n# URL WebSocket de Deriv\napi_url = f\"wss://ws.binaryws.com/websockets/v3?app_id={APP_ID}\"\n\n# Param√®tres de trading\nCONTRACT_TYPE = \"CALL/PUT\"  # Type de contrat\nDURATION = 15  # Dur√©e du contrat en minutes\nDURATION_UNIT = \"s\"  # m = minutesPY\nMIN_PAYOUT = 80  # Payout minimum en pourcentage\nMAX_TRADE_COUNT = 20  # Nombre maximal de trades par jour\nCOOLDOWN_SECONDS = 60  # Temps d'attente minimum entre les trades\nTRADE_COUNT = 0  # Compteur de trades\n\nclass Trade:\n    def __init__(self, trade_type, entry_price, entry_time, stop_loss, take_profit, amount):\n        self.trade_type = trade_type  # 'buy' ou 'sell'\n        self.entry_price = entry_price\n        self.entry_time = entry_time\n        self.stop_loss = stop_loss\n        self.take_profit = take_profit\n        self.amount = amount\n        self.exit_price = None\n        self.exit_time = None\n        self.profit = None\n        self.status = \"open\"  # open, closed\n        self.contract_id = None  # ID de contrat Deriv\n\n    def close(self, exit_price, exit_time):\n        self.exit_price = exit_price\n        self.exit_time = exit_time\n        \n        if self.trade_type == 'buy':\n            self.profit = (exit_price - self.entry_price) * self.amount\n        else:\n            self.profit = (self.entry_price - exit_price) * self.amount\n            \n        self.status = \"closed\"\n        return self.profit\n\ndef calculate_indicators(df):\n    if len(df) < RSI_PERIOD:\n        return df\n    \n    # Calculer le RSI\n    df['rsi'] = ta.momentum.rsi(df['close'], window=RSI_PERIOD)\n    \n    # Calculer les bandes de Bollinger\n    bollinger = ta.volatility.BollingerBands(df['close'], window=BOLLINGER_PERIOD, window_dev=BOLLINGER_STD)\n    df['bollinger_hband'] = bollinger.bollinger_hband()\n    df['bollinger_lband'] = bollinger.bollinger_lband()\n    df['bollinger_mavg'] = bollinger.bollinger_mavg()\n    \n    # Calculer l'ATR\n    df['atr'] = ta.volatility.average_true_range(\n        high=df['high'],\n        low=df['low'],\n        close=df['close'],\n        window=ATR_PERIOD\n    )\n    \n    return df\n\ndef check_trend_direction():\n    \"\"\"Analyser les 3 derniers ticks pour d√©tecter la tendance\"\"\"\n    if len(last_ticks) < 3:\n        return None, \"Pas assez de ticks\"\n    \n    # R√©cup√©rer les 3 derniers ticks\n    t1, t2, t3 = list(last_ticks)[-3:]\n    \n    # V√©rifier la tendance\n    if t3 > t2 > t1:\n        # S√©curit√© anti-latence: v√©rifier que le dernier tick suit la tendance\n        if len(last_ticks) >= 4 and t3 < list(last_ticks)[-4]:\n            return None, \"Signal CALL ignor√© - Anti-latence\"\n        return \"call\", \"Tendance haussi√®re - 3 ticks cons√©cutifs √† la hausse\"\n    \n    elif t3 < t2 < t1:\n        # S√©curit√© anti-latence: v√©rifier que le dernier tick suit la tendance\n        if len(last_ticks) >= 4 and t3 > list(last_ticks)[-4]:\n            return None, \"Signal PUT ignor√© - Anti-latence\"\n        return \"put\", \"Tendance baissi√®re - 3 ticks cons√©cutifs √† la baisse\"\n    \n    return None, \"Pas de tendance claire\"\n\ndef check_volatility():\n    \"\"\"V√©rifier la volatilit√© bas√©e sur le nombre de ticks par seconde\"\"\"\n    if not tick_rates or len(tick_rates) < 1:\n        return False, \"Pas assez de donn√©es pour √©valuer la volatilit√©\"\n    \n    # Calculer le nombre moyen de ticks par seconde sur les derni√®res donn√©es\n    avg_tick_rate = tick_rates[-1] if tick_rates else 0\n    \n    if avg_tick_rate >= MIN_TICK_RATE:\n        return True, f\"Volatilit√© acceptable ({avg_tick_rate:.2f} ticks/s)\"\n    else:\n        return False, f\"Volatilit√© trop faible ({avg_tick_rate:.2f} ticks/s)\"\n\ndef check_bollinger_breakout(df, trend):\n    \"\"\"V√©rifier si le prix a cass√© une bande de Bollinger avec un volume en hausse\"\"\"\n    if 'bollinger_hband' not in df.columns or len(df) < 2:\n        return False, \"Pas assez de donn√©es pour √©valuer le breakout\"\n    \n    last = df.iloc[-1]\n    prev = df.iloc[-2]\n    \n    # Estimer le volume en comparant les mouvements de prix\n    price_movement = abs(last['close'] - prev['close'])\n    volume_increasing = False\n    \n    if len(tick_volume) >= 2:\n        avg_recent_volume = sum(list(tick_volume)[-5:]) / 5\n        avg_previous_volume = sum(list(tick_volume)[-10:-5]) / 5\n        volume_increasing = avg_recent_volume > avg_previous_volume\n    \n    if trend == \"call\" and last['close'] > last['bollinger_hband'] and volume_increasing:\n        return True, \"Breakout de la bande sup√©rieure avec volume en hausse\"\n    \n    elif trend == \"put\" and last['close'] < last['bollinger_lband'] and volume_increasing:\n        return True, \"Breakout de la bande inf√©rieure avec volume en hausse\"\n    \n    return False, \"Pas de breakout des bandes de Bollinger\"\n\ndef check_rsi_filter(df, trend):\n    \"\"\"Filtrer les entr√©es en surachat ou survente avec le RSI\"\"\"\n    if 'rsi' not in df.columns:\n        return True, \"RSI non disponible\"\n    \n    last_rsi = df.iloc[-1]['rsi']\n    \n    if trend == \"call\" and last_rsi > 70:\n        return False, f\"RSI en surachat ({last_rsi:.2f} > 70) - CALL ignor√©\"\n    \n    elif trend == \"put\" and last_rsi < 30:\n        return False, f\"RSI en survente ({last_rsi:.2f} < 30) - PUT ignor√©\"\n    \n    return True, f\"RSI valide ({last_rsi:.2f})\"\n\ndef calculate_dynamic_tp_sl(df, trend):\n    \"\"\"Calculer le Take Profit et Stop Loss dynamiques bas√©s sur l'ATR\"\"\"\n    if 'atr' not in df.columns:\n        return None, None, \"ATR non disponible\"\n    \n    last = df.iloc[-1]\n    atr = last['atr']\n    \n    # D√©terminer le ratio de r√©compense/risque en fonction de la volatilit√©\n    reward_risk_ratio = REWARD_RISK_RATIO_HIGH_VOL if atr > 3 else REWARD_RISK_RATIO_LOW_VOL\n    \n    # Calculer SL et TP\n    if trend == \"call\":\n        sl = last['close'] - (2 * atr)\n        tp = last['close'] + (reward_risk_ratio * 2 * atr)\n    else:  # put\n        sl = last['close'] + (2 * atr)\n        tp = last['close'] - (reward_risk_ratio * 2 * atr)\n    \n    return tp, sl, f\"TP/SL bas√©s sur ATR={atr:.2f} (Ratio={reward_risk_ratio})\"\n\ndef can_place_order():\n    global last_order_time, TRADE_COUNT, MAX_TRADE_COUNT\n    \n    # V√©rifier si nous avons atteint la limite de trades par jour\n    if TRADE_COUNT >= MAX_TRADE_COUNT:\n        return False, \"Limite de trades par jour atteinte\"\n    \n    # V√©rifier le temps √©coul√© depuis le dernier ordre\n    if last_order_time is not None:\n        elapsed = (datetime.datetime.now() - last_order_time).total_seconds()\n        if elapsed < COOLDOWN_SECONDS:\n            return False, f\"Cooldown en cours ({COOLDOWN_SECONDS - int(elapsed)}s restantes)\"\n    \n    return True, \"Pr√™t √† trader\"\n\ndef place_order(action, trade):\n    \"\"\"Placer un ordre sur Deriv via l'API WebSocket\"\"\"\n    global TRADE_COUNT, last_order_time, active_contracts, ws_global\n\n    # V√©rifier si nous pouvons placer un ordre\n    can_trade, reason = can_place_order()\n    if not can_trade:\n        print(f\"Ordre non plac√©: {reason}\")\n        return False\n\n    # D√©finir le type de contrat en fonction de l'action\n    contract_type = \"CALL\" if action == \"call\" else \"PUT\"\n    \n    # Calculer le montant en fonction du risque et du solde\n    amount = round(account_balance * RISK_PER_TRADE, 2)\n    \n    # Cr√©er la requ√™te d'achat\n    buy_request = {\n    \"buy\": 1,\n    \"subscribe\": 1,\n    \"price\": amount,\n    \"parameters\": {\n        \"contract_type\": contract_type,\n        \"symbol\": SYMBOL,\n        \"duration\": DURATION,\n        \"duration_unit\": DURATION_UNIT,\n        \"basis\": \"stake\",  # Sp√©cifie que vous utilisez un montant fixe\n        \"amount\": amount,  # Ajoutez cette ligne explicitement\n        \"currency\": \"USD\"  # Ajouter cette ligne\n    }\n}\n    \n    # Envoyer la requ√™te √† l'API\n    ws_global.send(json.dumps(buy_request))\n    \n    # Mettre √† jour le compteur et le timestamp\n    TRADE_COUNT += 1\n    last_order_time = datetime.datetime.now()\n    \n    print(f\"ORDRE R√âEL ENVOY√â: {contract_type} pour {SYMBOL}, montant: {amount} {account_currency}\")\n    print(f\"Dur√©e: {DURATION} {DURATION_UNIT}, Heure: {last_order_time}\")\n    \n    return True\n\ndef execute_strategy(df):\n    global current_trade, account_balance, TRADE_COUNT\n    \n    if len(df) < RSI_PERIOD or len(last_ticks) < 3:\n        return \"Collecte de donn√©es... Strat√©gie inactive\"\n    \n    # V√©rifier si nous pouvons trader\n    can_trade, reason = can_place_order()\n    if not can_trade:\n        return f\"Trading suspendu: {reason}\"\n    \n    # V√©rifier les signaux d'entr√©e\n    # 1. D√©tection de la tendance\n    trend, trend_message = check_trend_direction()\n    if not trend:\n        return f\"Pas de signal: {trend_message}\"\n    \n    # 2. Filtre de volatilit√©\n    volatility_ok, volatility_message = check_volatility()\n    if not volatility_ok:\n        return f\"Signal ignor√©: {volatility_message}\"\n    \n    # 3. Confirmation avec Bandes de Bollinger\n    breakout_ok, breakout_message = check_bollinger_breakout(df, trend)\n    if not breakout_ok:\n        return f\"Signal ignor√©: {breakout_message}\"\n    \n    # 4. Filtre RSI\n    rsi_ok, rsi_message = check_rsi_filter(df, trend)\n    if not rsi_ok:\n        return f\"Signal ignor√©: {rsi_message}\"\n    \n    # 5 & 6. Calcul du TP et SL dynamiques\n    tp, sl, tp_sl_message = calculate_dynamic_tp_sl(df, trend)\n    if not tp or not sl:\n        return f\"Signal ignor√©: {tp_sl_message}\"\n    \n    # Toutes les conditions sont remplies, cr√©er un trade\n    last_row = df.iloc[-1]\n    entry_price = last_row['close']\n    current_time = last_row['time']\n    \n    # Calculer la taille de position bas√©e sur le risque\n    risk_amount = account_balance * RISK_PER_TRADE\n    position_size = risk_amount / abs(entry_price - sl)\n    \n    # Cr√©er la position\n    trade_type = 'buy' if trend == 'call' else 'sell'\n    current_trade = Trade(trade_type, entry_price, current_time, sl, tp, position_size)\n    \n    message = f\"SIGNAL {trend.upper()}: {trend_message} | {volatility_message} | {breakout_message} | {rsi_message} | {tp_sl_message}\"\n    message += f\"\\nEntr√©e: {entry_price:.2f} | SL: {sl:.2f} | TP: {tp:.2f}\"\n    print(message)\n    \n    # Placer l'ordre sur Deriv\n    order_placed = place_order(trend, current_trade)\n    \n    if order_placed:\n        return f\"TRADE EX√âCUT√â: {trend.upper()} √† {entry_price:.2f}\"\n    else:\n        current_trade = None  # R√©initialiser si l'ordre n'a pas √©t√© plac√©\n        return \"Ordre non ex√©cut√©\"\n\ndef count_ticks_per_second():\n    \"\"\"Calculer le nombre de ticks par seconde\"\"\"\n    global tick_rates\n    \n    if len(last_tick_times) < 2:\n        return\n    \n    # Regrouper les timestamps par seconde\n    seconds = {}\n    for ts in last_tick_times:\n        second_key = ts.replace(microsecond=0)\n        if second_key in seconds:\n            seconds[second_key] += 1\n        else:\n            seconds[second_key] = 1\n    \n    # Calculer le nombre moyen de ticks par seconde sur les derni√®res secondes\n    if seconds:\n        recent_seconds = sorted(seconds.keys())[-min(len(seconds), 5):]\n        recent_tick_rates = [seconds[sec] for sec in recent_seconds]\n        tick_rates.append(sum(recent_tick_rates) / len(recent_tick_rates))\n\ndef process_contract_update(data):\n    \"\"\"Traiter les mises √† jour des contrats\"\"\"\n    global active_contracts, account_balance, trade_history\n    \n    if \"buy\" in data:\n        # Nouvel achat confirm√©\n        contract_id = data[\"buy\"][\"contract_id\"]\n        active_contracts[contract_id] = {\n            \"buy_price\": data[\"buy\"][\"buy_price\"],\n            \"payout\": data[\"buy\"][\"payout\"],\n            \"start_time\": datetime.datetime.now(),\n            \"contract_type\": data[\"buy\"][\"parameters\"][\"contract_type\"]\n        }\n        print(f\"Contrat {contract_id} achet√© pour {data['buy']['buy_price']} {account_currency}\")\n        \n        # Mettre √† jour le solde\n        if \"balance_after\" in data[\"buy\"]:\n            account_balance = data[\"buy\"][\"balance_after\"]\n            print(f\"Nouveau solde: {account_balance} {account_currency}\")\n    \n    elif \"proposal_open_contract\" in data and \"contract_id\" in data[\"proposal_open_contract\"]:\n        # Mise √† jour d'un contrat existant\n        contract_id = data[\"proposal_open_contract\"][\"contract_id\"]\n        \n        if contract_id in active_contracts:\n            # Mettre √† jour les informations\n            active_contracts[contract_id][\"current_spot\"] = data[\"proposal_open_contract\"].get(\"current_spot\")\n            active_contracts[contract_id][\"current_value\"] = data[\"proposal_open_contract\"].get(\"bid_price\")\n            \n            # V√©rifier si le contrat est termin√©\n            if data[\"proposal_open_contract\"][\"is_sold\"] == 1:\n                profit = data[\"proposal_open_contract\"][\"profit\"]\n                print(f\"Contrat {contract_id} termin√© avec un profit de {profit} {account_currency}\")\n                \n                # Cr√©er un historique\n                trade_info = active_contracts[contract_id]\n                trade_result = {\n                    \"contract_id\": contract_id,\n                    \"type\": trade_info[\"contract_type\"],\n                    \"entry\": trade_info[\"buy_price\"],\n                    \"exit\": data[\"proposal_open_contract\"][\"sell_price\"],\n                    \"profit\": profit,\n                    \"start_time\": trade_info[\"start_time\"],\n                    \"end_time\": datetime.datetime.now()\n                }\n                trade_history.append(trade_result)\n                \n                # Mettre √† jour le solde\n                if \"balance_after\" in data[\"proposal_open_contract\"]:\n                    account_balance = data[\"proposal_open_contract\"][\"balance_after\"]\n                    print(f\"Nouveau solde apr√®s cl√¥ture: {account_balance} {account_currency}\")\n                \n                # Supprimer le contrat des actifs\n                del active_contracts[contract_id]\n\ndef on_message(ws, message):\n    global account_balance, account_currency, df, ws_global\n    \n    ws_global = ws  # Stocker la r√©f√©rence WebSocket globale\n    \n    try:\n        response = json.loads(message)\n        \n        # Traitement des ticks\n        if \"tick\" in response:\n            tick = response[\"tick\"]\n            price = tick[\"quote\"]\n            timestamp = datetime.datetime.fromtimestamp(tick[\"epoch\"])\n            \n            # Ajouter le tick √† la liste des derniers ticks\n            last_ticks.append(price)\n            last_tick_times.append(timestamp)\n            \n            # Mettre √† jour l'√©cran avec les derniers prix\n            print(f\"[{timestamp.strftime('%H:%M:%S')}] Prix: {price}, Ask: {tick['ask']}, Bid: {tick['bid']}\")\n            \n            # Calculer le volume fictif (bas√© sur le mouvement de prix)\n            if len(last_ticks) >= 2:\n                price_movement = abs(last_ticks[-1] - last_ticks[-2])\n                tick_volume.append(price_movement)\n            \n            # Mettre √† jour le nombre de ticks par seconde\n            count_ticks_per_second()\n            \n            # Cr√©er des donn√©es OHLC √† partir des ticks\n            # Pour simplifier, nous utilisons une approche bas√©e sur les ticks plut√¥t que sur le temps\n            if len(ticks_data) == 0 or len(ticks_data) % 5 == 0:  # Cr√©er une nouvelle \"bougie\" tous les 5 ticks\n                # Ajouter les donn√©es aux listes\n                ticks_data.append(price)\n                timestamps.append(timestamp)\n                \n                # Pour simplifier, nous utilisons le m√™me prix pour open, high, low\n                # Dans un cas r√©el, on accumulerait les ticks pour former des bougies\n                new_row = pd.DataFrame({\n                    'time': [timestamp],\n                    'open': [price],\n                    'high': [price],\n                    'low': [price],\n                    'close': [price],\n                    'volume': [1]\n                })\n                \n                # Mettre √† jour le DataFrame\n                df = pd.concat([df, new_row], ignore_index=True)\n            else:\n                # Mettre √† jour la derni√®re \"bougie\"\n                ticks_data.append(price)\n                \n                # Mettre √† jour les valeurs high, low, close\n                df.at[len(df)-1, 'high'] = max(df.iloc[-1]['high'], price)\n                df.at[len(df)-1, 'low'] = min(df.iloc[-1]['low'], price)\n                df.at[len(df)-1, 'close'] = price\n                df.at[len(df)-1, 'volume'] += 1\n            \n            # Limiter la taille du DataFrame pour les performances\n            if len(df) > RSI_PERIOD * 3:\n                df = df.iloc[-RSI_PERIOD*3:]\n            \n            # Calculer les indicateurs\n            if len(df) > RSI_PERIOD:\n                df = calculate_indicators(df)\n                \n                # Ex√©cuter la strat√©gie\n                strategy_message = execute_strategy(df)\n                if \"TRADE EX√âCUT√â\" in strategy_message:\n                    print(\"=\" * 50)\n                    print(strategy_message)\n                    print(\"=\" * 50)\n        \n        # Traitement des informations du compte\n        elif \"authorize\" in response and response[\"authorize\"]:\n            account_info = response[\"authorize\"]\n            account_balance = account_info[\"balance\"]\n            account_currency = account_info[\"currency\"]\n            \n            print(\"=\" * 50)\n            print(f\"CONNEXION R√âUSSIE | Solde: {account_balance} {account_currency}\")\n            print(\"=\" * 50)\n            \n            # Demander le flux de ticks pour Volatility 100 Index\n            subscribe_ticks(ws)\n        \n        # Traitement des mises √† jour de contrat\n        elif \"buy\" in response or \"proposal_open_contract\" in response:\n            process_contract_update(response)\n        \n        # Gestion des erreurs\n        elif \"error\" in response:\n            print(f\"ERREUR API: {response['error']['message']}\")\n    \n    except Exception as e:\n        print(f\"Erreur lors du traitement du message: {e}\")\n\ndef on_error(ws, error):\n    print(f\"Erreur de connexion: {error}\")\n\ndef on_close(ws, close_status_code, close_msg):\n    print(f\"Connexion ferm√©e: {close_status_code} - {close_msg}\")\n    print(\"Tentative de reconnexion dans 5 secondes...\")\n    time.sleep(5)\n    connect_websocket()\n\ndef on_open(ws):\n    print(\"=\" * 50)\n    print(\"CONNEXION WEBSOCKET √âTABLIE\")\n    print(\"Bot de trading automatique d√©marr√©\")\n    print(\"Volatility 100 Index (1s) - Strat√©gie de Scalping\")\n    print(\"=\" * 50)\n    \n    # Authentification avec le token API\n    auth_req = {\n        \"authorize\": TOKEN\n    }\n    ws.send(json.dumps(auth_req))\n    print(\"Requ√™te d'authentification envoy√©e\")\n\ndef subscribe_ticks(ws):\n    # S'abonner aux ticks pour Volatility 100 Index\n    ticks_request = {\n        \"ticks\": SYMBOL,\n        \"subscribe\": 1\n    }\n    ws.send(json.dumps(ticks_request))\n    print(f\"Abonnement aux ticks pour {SYMBOL}\")\n\ndef connect_websocket():\n    global ws_global\n    # Configuration et d√©marrage du WebSocket\n    websocket.enableTrace(False)  # D√©sactiver les traces pour une sortie plus propre\n    ws = websocket.WebSocketApp(\n        api_url,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close\n    )\n    \n    ws_global = ws\n    \n    # Lancer le WebSocket\n    ws.run_forever(dispatcher=rel)\n    return ws\n\ndef main():\n    global df\n    \n    # Initialiser le DataFrame avec les colonnes n√©cessaires\n    df = pd.DataFrame(columns=['time', 'open', 'high', 'low', 'close', 'volume'])\n    \n    # Afficher les informations de d√©marrage\n    print(\"=\" * 50)\n    print(\"D√âMARRAGE DU BOT DE TRADING DERIV\")\n    print(f\"Token: {TOKEN[:4]}...{TOKEN[-4:]}\")\n    print(f\"Symbole: {SYMBOL}\")\n    print(f\"Risque par trade: {RISK_PER_TRADE*100}%\")\n    print(f\"Max trades par jour: {MAX_TRADE_COUNT}\")\n    print(\"=\" * 50)\n    \n    # Connecter au WebSocket\n    connect_websocket()\n    \n    # Boucle principale pour maintenir le programme en cours d'ex√©cution\n    rel.signal(2, rel.abort)  # Intercepter Ctrl+C\n    rel.dispatch()\n\nif __name__ == \"__main__\":\n    try:\n        # Variable globale pour stocker la r√©f√©rence WebSocket\n        ws_global = None\n        \n        # D√©marrer le bot\n        main()\n    except Exception as e:\n        print(f\"Erreur dans le programme principal: {e}\")\n        \n        if missing_packages:\n            print(f\"Packages manquants: {', '.join(missing_packages)}\")\n            print(\"Veuillez installer les packages manquants avec la commande suivante:\")\n            print(f\"pip install {' '.join(missing_packages)}\")\n        else:\n            # Variable globale pour stocker la r√©f√©rence WebSocket\n            ws_global = None\n            \n            # D√©marrer le bot\n            main()\n    except Exception as e:\n        print(f\"Erreur dans le programme principal: {e}\")",
    "language": "python",
    "description": "meilleur ",
    "tags": [
      "python"
    ],
    "createdAt": "2025-03-07T23:14:30.343Z",
    "updatedAt": "2025-03-07T23:14:30.352Z"
  },
  {
    "id": "273948a7-1f8c-4015-bbda-843100e0dc81",
    "title": "bot.py",
    "code": "import websocket\r\nimport json\r\nimport time\r\nimport datetime\r\nimport threading\r\nimport numpy as np\r\nimport pandas as pd\r\nimport ta\r\nfrom collections import deque\r\nimport rel\r\n\r\n# Configuration\r\nAPP_ID = \"1089\" \r\nAPI_TOKEN = \"xIEK9p4hVgl5XDC\"\r\nTOKEN = API_TOKEN  # Ajout de cette ligne\r\nSYMBOL = \"R_100\"\r\n\r\n# Param√®tres de la strat√©gie\r\nRSI_PERIOD = 14\r\nBOLLINGER_PERIOD = 20\r\nBOLLINGER_STD = 2\r\nATR_PERIOD = 5\r\nRISK_PER_TRADE = 0.02  # 2% du capital\r\nREWARD_RISK_RATIO_HIGH_VOL = 2.0  # Pour ATR > 3\r\nREWARD_RISK_RATIO_LOW_VOL = 1.5   # Pour ATR < 3\r\nMIN_TICK_RATE = 0.4  # Ajust√© pour fonctionner avec 1 tick toutes les 2-3 secondes\r\n\r\n# Variables pour stocker les donn√©es\r\nticks_data = []\r\ntimestamps = []\r\ntick_rates = []  # Nombre de ticks par seconde\r\nvolume_data = []  # Volume fictif bas√© sur les mouvements de prix\r\naccount_balance = None\r\naccount_currency = None\r\ncurrent_trade = None\r\ntrade_history = []\r\npositions = []\r\nactive_contracts = {}  # Pour stocker les contrats actifs\r\nlast_order_time = None  # Pour limiter la fr√©quence des trades\r\n\r\n# Files pour m√©moriser les derniers ticks et leur timestamp\r\nlast_ticks = deque(maxlen=50)  # Garder plus de ticks pour les calculs\r\nlast_tick_times = deque(maxlen=50)\r\ntick_volume = deque(maxlen=20)  # Pour estimer le volume bas√© sur les mouvements de prix\r\n\r\n# URL WebSocket de Deriv\r\napi_url = f\"wss://ws.binaryws.com/websockets/v3?app_id={APP_ID}\"\r\n\r\n# Param√®tres de trading\r\nCONTRACT_TYPE = \"CALL/PUT\"  # Type de contrat\r\nDURATION = 15  # Dur√©e du contrat en minutes\r\nDURATION_UNIT = \"s\"  # m = minutesPY\r\nMIN_PAYOUT = 80  # Payout minimum en pourcentage\r\nMAX_TRADE_COUNT = 200  # Nombre maximal de trades par jour\r\n\r\nCOOLDOWN_SECONDS = 60  # Temps d'attente minimum entre les trades\r\nTRADE_COUNT = 0  # Compteur de trades\r\n\r\nclass Trade:\r\n    def __init__(self, trade_type, entry_price, entry_time, stop_loss, take_profit, amount):\r\n        self.trade_type = trade_type  # 'buy' ou 'sell'\r\n        self.entry_price = entry_price\r\n        self.entry_time = entry_time\r\n        self.stop_loss = stop_loss\r\n        self.take_profit = take_profit\r\n        self.amount = amount\r\n        self.exit_price = None\r\n        self.exit_time = None\r\n        self.profit = None\r\n        self.status = \"open\"  # open, closed\r\n        self.contract_id = None  # ID de contrat Deriv\r\n\r\n    def close(self, exit_price, exit_time):\r\n        self.exit_price = exit_price\r\n        self.exit_time = exit_time\r\n        \r\n        if self.trade_type == 'buy':\r\n            self.profit = (exit_price - self.entry_price) * self.amount\r\n        else:\r\n            self.profit = (self.entry_price - exit_price) * self.amount\r\n            \r\n        self.status = \"closed\"\r\n        return self.profit\r\n\r\ndef calculate_indicators(df):\r\n    if len(df) < RSI_PERIOD:\r\n        return df\r\n    \r\n    # Calculer le RSI\r\n    df['rsi'] = ta.momentum.rsi(df['close'], window=RSI_PERIOD)\r\n    \r\n    # Calculer les bandes de Bollinger\r\n    bollinger = ta.volatility.BollingerBands(df['close'], window=BOLLINGER_PERIOD, window_dev=BOLLINGER_STD)\r\n    df['bollinger_hband'] = bollinger.bollinger_hband()\r\n    df['bollinger_lband'] = bollinger.bollinger_lband()\r\n    df['bollinger_mavg'] = bollinger.bollinger_mavg()\r\n    \r\n    # Calculer l'ATR\r\n    df['atr'] = ta.volatility.average_true_range(\r\n        high=df['high'],\r\n        low=df['low'],\r\n        close=df['close'],\r\n        window=ATR_PERIOD\r\n    )\r\n    \r\n    return df\r\n\r\ndef check_trend_direction():\r\n    \"\"\"Analyser les 3 derniers ticks pour d√©tecter la tendance\"\"\"\r\n    if len(last_ticks) < 3:\r\n        return None, \"Pas assez de ticks\"\r\n    \r\n    # R√©cup√©rer les 3 derniers ticks\r\n    t1, t2, t3 = list(last_ticks)[-3:]\r\n    \r\n    # V√©rifier la tendance\r\n    if t3 > t2 > t1:\r\n        # S√©curit√© anti-latence: v√©rifier que le dernier tick suit la tendance\r\n        if len(last_ticks) >= 4 and t3 < list(last_ticks)[-4]:\r\n            return None, \"Signal CALL ignor√© - Anti-latence\"\r\n        return \"call\", \"Tendance haussi√®re - 3 ticks cons√©cutifs √† la hausse\"\r\n    \r\n    elif t3 < t2 < t1:\r\n        # S√©curit√© anti-latence: v√©rifier que le dernier tick suit la tendance\r\n        if len(last_ticks) >= 4 and t3 > list(last_ticks)[-4]:\r\n            return None, \"Signal PUT ignor√© - Anti-latence\"\r\n        return \"put\", \"Tendance baissi√®re - 3 ticks cons√©cutifs √† la baisse\"\r\n    \r\n    return None, \"Pas de tendance claire\"\r\n\r\ndef check_volatility():\r\n    \"\"\"V√©rifier la volatilit√© bas√©e sur le nombre de ticks par seconde\"\"\"\r\n    if not tick_rates or len(tick_rates) < 1:\r\n        return False, \"Pas assez de donn√©es pour √©valuer la volatilit√©\"\r\n    \r\n    # Calculer le nombre moyen de ticks par seconde sur les derni√®res donn√©es\r\n    avg_tick_rate = tick_rates[-1] if tick_rates else 0\r\n    \r\n    if avg_tick_rate >= MIN_TICK_RATE:\r\n        return True, f\"Volatilit√© acceptable ({avg_tick_rate:.2f} ticks/s)\"\r\n    else:\r\n        return False, f\"Volatilit√© trop faible ({avg_tick_rate:.2f} ticks/s)\"\r\n\r\ndef check_bollinger_breakout(df, trend):\r\n    \"\"\"V√©rifier si le prix a cass√© une bande de Bollinger avec un volume en hausse\"\"\"\r\n    if 'bollinger_hband' not in df.columns or len(df) < 2:\r\n        return False, \"Pas assez de donn√©es pour √©valuer le breakout\"\r\n    \r\n    last = df.iloc[-1]\r\n    prev = df.iloc[-2]\r\n    \r\n    # Estimer le volume en comparant les mouvements de prix\r\n    price_movement = abs(last['close'] - prev['close'])\r\n    volume_increasing = False\r\n    \r\n    if len(tick_volume) >= 2:\r\n        avg_recent_volume = sum(list(tick_volume)[-5:]) / 5\r\n        avg_previous_volume = sum(list(tick_volume)[-10:-5]) / 5\r\n        volume_increasing = avg_recent_volume > avg_previous_volume\r\n    \r\n    if trend == \"call\" and last['close'] > last['bollinger_hband'] and volume_increasing:\r\n        return True, \"Breakout de la bande sup√©rieure avec volume en hausse\"\r\n    \r\n    elif trend == \"put\" and last['close'] < last['bollinger_lband'] and volume_increasing:\r\n        return True, \"Breakout de la bande inf√©rieure avec volume en hausse\"\r\n    \r\n    return False, \"Pas de breakout des bandes de Bollinger\"\r\n\r\ndef check_rsi_filter(df, trend):\r\n    \"\"\"Filtrer les entr√©es en surachat ou survente avec le RSI\"\"\"\r\n    if 'rsi' not in df.columns:\r\n        return True, \"RSI non disponible\"\r\n    \r\n    last_rsi = df.iloc[-1]['rsi']\r\n    \r\n    if trend == \"call\" and last_rsi > 70:\r\n        return False, f\"RSI en surachat ({last_rsi:.2f} > 70) - CALL ignor√©\"\r\n    \r\n    elif trend == \"put\" and last_rsi < 30:\r\n        return False, f\"RSI en survente ({last_rsi:.2f} < 30) - PUT ignor√©\"\r\n    \r\n    return True, f\"RSI valide ({last_rsi:.2f})\"\r\n\r\ndef calculate_dynamic_tp_sl(df, trend):\r\n    \"\"\"Calculer le Take Profit et Stop Loss dynamiques bas√©s sur l'ATR\"\"\"\r\n    if 'atr' not in df.columns:\r\n        return None, None, \"ATR non disponible\"\r\n    \r\n    last = df.iloc[-1]\r\n    atr = last['atr']\r\n    \r\n    # D√©terminer le ratio de r√©compense/risque en fonction de la volatilit√©\r\n    reward_risk_ratio = REWARD_RISK_RATIO_HIGH_VOL if atr > 3 else REWARD_RISK_RATIO_LOW_VOL\r\n    \r\n    # Calculer SL et TP\r\n    if trend == \"call\":\r\n        sl = last['close'] - (2 * atr)\r\n        tp = last['close'] + (reward_risk_ratio * 2 * atr)\r\n    else:  # put\r\n        sl = last['close'] + (2 * atr)\r\n        tp = last['close'] - (reward_risk_ratio * 2 * atr)\r\n    \r\n    return tp, sl, f\"TP/SL bas√©s sur ATR={atr:.2f} (Ratio={reward_risk_ratio})\"\r\n\r\ndef can_place_order():\r\n    global last_order_time, TRADE_COUNT, MAX_TRADE_COUNT\r\n    \r\n    # V√©rifier si nous avons atteint la limite de trades par jour\r\n    if TRADE_COUNT >= MAX_TRADE_COUNT:\r\n        return False, \"Limite de trades par jour atteinte\"\r\n    \r\n    # V√©rifier le temps √©coul√© depuis le dernier ordre\r\n    if last_order_time is not None:\r\n        elapsed = (datetime.datetime.now() - last_order_time).total_seconds()\r\n        if elapsed < COOLDOWN_SECONDS:\r\n            return False, f\"Cooldown en cours ({COOLDOWN_SECONDS - int(elapsed)}s restantes)\"\r\n    \r\n    return True, \"Pr√™t √† trader\"\r\n\r\ndef place_order(action, trade):\r\n    \"\"\"Placer un ordre sur Deriv via l'API WebSocket\"\"\"\r\n    global TRADE_COUNT, last_order_time, active_contracts, ws_global\r\n\r\n    # V√©rifier si nous pouvons placer un ordre\r\n    can_trade, reason = can_place_order()\r\n    if not can_trade:\r\n        print(f\"Ordre non plac√©: {reason}\")\r\n        return False\r\n\r\n    # D√©finir le type de contrat en fonction de l'action\r\n    contract_type = \"CALL\" if action == \"call\" else \"PUT\"\r\n    \r\n    # Calculer le montant en fonction du risque et du solde\r\n    amount = round(account_balance * RISK_PER_TRADE, 2)\r\n    \r\n    # Cr√©er la requ√™te d'achat\r\n    buy_request = {\r\n    \"buy\": 1,\r\n    \"subscribe\": 1,\r\n    \"price\": amount,\r\n    \"parameters\": {\r\n        \"contract_type\": contract_type,\r\n        \"symbol\": SYMBOL,\r\n        \"duration\": DURATION,\r\n        \"duration_unit\": DURATION_UNIT,\r\n        \"basis\": \"stake\",  # Sp√©cifie que vous utilisez un montant fixe\r\n        \"amount\": amount,  # Ajoutez cette ligne explicitement\r\n        \"currency\": \"USD\"  # Ajouter cette ligne\r\n    }\r\n}\r\n    \r\n    # Envoyer la requ√™te √† l'API\r\n    ws_global.send(json.dumps(buy_request))\r\n    \r\n    # Mettre √† jour le compteur et le timestamp\r\n    TRADE_COUNT += 1\r\n    last_order_time = datetime.datetime.now()\r\n    \r\n    print(f\"ORDRE R√âEL ENVOY√â: {contract_type} pour {SYMBOL}, montant: {amount} {account_currency}\")\r\n    print(f\"Dur√©e: {DURATION} {DURATION_UNIT}, Heure: {last_order_time}\")\r\n    \r\n    return True\r\n\r\ndef execute_strategy(df):\r\n    global current_trade, account_balance, TRADE_COUNT\r\n    \r\n    if len(df) < RSI_PERIOD or len(last_ticks) < 3:\r\n        return \"Collecte de donn√©es... Strat√©gie inactive\"\r\n    \r\n    # V√©rifier si nous pouvons trader\r\n    can_trade, reason = can_place_order()\r\n    if not can_trade:\r\n        return f\"Trading suspendu: {reason}\"\r\n    \r\n    # V√©rifier les signaux d'entr√©e\r\n    # 1. D√©tection de la tendance\r\n    trend, trend_message = check_trend_direction()\r\n    if not trend:\r\n        return f\"Pas de signal: {trend_message}\"\r\n    \r\n    # 2. Filtre de volatilit√©\r\n    volatility_ok, volatility_message = check_volatility()\r\n    if not volatility_ok:\r\n        return f\"Signal ignor√©: {volatility_message}\"\r\n    \r\n    # 3. Confirmation avec Bandes de Bollinger\r\n    breakout_ok, breakout_message = check_bollinger_breakout(df, trend)\r\n    if not breakout_ok:\r\n        return f\"Signal ignor√©: {breakout_message}\"\r\n    \r\n    # 4. Filtre RSI\r\n    rsi_ok, rsi_message = check_rsi_filter(df, trend)\r\n    if not rsi_ok:\r\n        return f\"Signal ignor√©: {rsi_message}\"\r\n    \r\n    # 5 & 6. Calcul du TP et SL dynamiques\r\n    tp, sl, tp_sl_message = calculate_dynamic_tp_sl(df, trend)\r\n    if not tp or not sl:\r\n        return f\"Signal ignor√©: {tp_sl_message}\"\r\n    \r\n    # Toutes les conditions sont remplies, cr√©er un trade\r\n    last_row = df.iloc[-1]\r\n    entry_price = last_row['close']\r\n    current_time = last_row['time']\r\n    \r\n    # Calculer la taille de position bas√©e sur le risque\r\n    risk_amount = account_balance * RISK_PER_TRADE\r\n    position_size = risk_amount / abs(entry_price - sl)\r\n    \r\n    # Cr√©er la position\r\n    trade_type = 'buy' if trend == 'call' else 'sell'\r\n    current_trade = Trade(trade_type, entry_price, current_time, sl, tp, position_size)\r\n    \r\n    message = f\"SIGNAL {trend.upper()}: {trend_message} | {volatility_message} | {breakout_message} | {rsi_message} | {tp_sl_message}\"\r\n    message += f\"\\nEntr√©e: {entry_price:.2f} | SL: {sl:.2f} | TP: {tp:.2f}\"\r\n    print(message)\r\n    \r\n    # Placer l'ordre sur Deriv\r\n    order_placed = place_order(trend, current_trade)\r\n    \r\n    if order_placed:\r\n        return f\"TRADE EX√âCUT√â: {trend.upper()} √† {entry_price:.2f}\"\r\n    else:\r\n        current_trade = None  # R√©initialiser si l'ordre n'a pas √©t√© plac√©\r\n        return \"Ordre non ex√©cut√©\"\r\n\r\ndef count_ticks_per_second():\r\n    \"\"\"Calculer le nombre de ticks par seconde\"\"\"\r\n    global tick_rates\r\n    \r\n    if len(last_tick_times) < 2:\r\n        return\r\n    \r\n    # Regrouper les timestamps par seconde\r\n    seconds = {}\r\n    for ts in last_tick_times:\r\n        second_key = ts.replace(microsecond=0)\r\n        if second_key in seconds:\r\n            seconds[second_key] += 1\r\n        else:\r\n            seconds[second_key] = 1\r\n    \r\n    # Calculer le nombre moyen de ticks par seconde sur les derni√®res secondes\r\n    if seconds:\r\n        recent_seconds = sorted(seconds.keys())[-min(len(seconds), 5):]\r\n        recent_tick_rates = [seconds[sec] for sec in recent_seconds]\r\n        tick_rates.append(sum(recent_tick_rates) / len(recent_tick_rates))\r\n\r\ndef process_contract_update(data):\r\n    \"\"\"Traiter les mises √† jour des contrats\"\"\"\r\n    global active_contracts, account_balance, trade_history\r\n    \r\n    if \"buy\" in data:\r\n        # Nouvel achat confirm√©\r\n        contract_id = data[\"buy\"][\"contract_id\"]\r\n        active_contracts[contract_id] = {\r\n            \"buy_price\": data[\"buy\"][\"buy_price\"],\r\n            \"payout\": data[\"buy\"][\"payout\"],\r\n            \"start_time\": datetime.datetime.now(),\r\n            \"contract_type\": data[\"buy\"][\"parameters\"][\"contract_type\"]\r\n        }\r\n        print(f\"Contrat {contract_id} achet√© pour {data['buy']['buy_price']} {account_currency}\")\r\n        \r\n        # Mettre √† jour le solde\r\n        if \"balance_after\" in data[\"buy\"]:\r\n            account_balance = data[\"buy\"][\"balance_after\"]\r\n            print(f\"Nouveau solde: {account_balance} {account_currency}\")\r\n    \r\n    elif \"proposal_open_contract\" in data and \"contract_id\" in data[\"proposal_open_contract\"]:\r\n        # Mise √† jour d'un contrat existant\r\n        contract_id = data[\"proposal_open_contract\"][\"contract_id\"]\r\n        \r\n        if contract_id in active_contracts:\r\n            # Mettre √† jour les informations\r\n            active_contracts[contract_id][\"current_spot\"] = data[\"proposal_open_contract\"].get(\"current_spot\")\r\n            active_contracts[contract_id][\"current_value\"] = data[\"proposal_open_contract\"].get(\"bid_price\")\r\n            \r\n            # V√©rifier si le contrat est termin√©\r\n            if data[\"proposal_open_contract\"][\"is_sold\"] == 1:\r\n                profit = data[\"proposal_open_contract\"][\"profit\"]\r\n                print(f\"Contrat {contract_id} termin√© avec un profit de {profit} {account_currency}\")\r\n                \r\n                # Cr√©er un historique\r\n                trade_info = active_contracts[contract_id]\r\n                trade_result = {\r\n                    \"contract_id\": contract_id,\r\n                    \"type\": trade_info[\"contract_type\"],\r\n                    \"entry\": trade_info[\"buy_price\"],\r\n                    \"exit\": data[\"proposal_open_contract\"][\"sell_price\"],\r\n                    \"profit\": profit,\r\n                    \"start_time\": trade_info[\"start_time\"],\r\n                    \"end_time\": datetime.datetime.now()\r\n                }\r\n                trade_history.append(trade_result)\r\n                \r\n                # Mettre √† jour le solde\r\n                if \"balance_after\" in data[\"proposal_open_contract\"]:\r\n                    account_balance = data[\"proposal_open_contract\"][\"balance_after\"]\r\n                    print(f\"Nouveau solde apr√®s cl√¥ture: {account_balance} {account_currency}\")\r\n                \r\n                # Supprimer le contrat des actifs\r\n                del active_contracts[contract_id]\r\n\r\ndef on_message(ws, message):\r\n    global account_balance, account_currency, df, ws_global\r\n    \r\n    ws_global = ws  # Stocker la r√©f√©rence WebSocket globale\r\n    \r\n    try:\r\n        response = json.loads(message)\r\n        \r\n        # Traitement des ticks\r\n        if \"tick\" in response:\r\n            tick = response[\"tick\"]\r\n            price = tick[\"quote\"]\r\n            timestamp = datetime.datetime.fromtimestamp(tick[\"epoch\"])\r\n            \r\n            # Ajouter le tick √† la liste des derniers ticks\r\n            last_ticks.append(price)\r\n            last_tick_times.append(timestamp)\r\n            \r\n            # Mettre √† jour l'√©cran avec les derniers prix\r\n            print(f\"[{timestamp.strftime('%H:%M:%S')}] Prix: {price}, Ask: {tick['ask']}, Bid: {tick['bid']}\")\r\n            \r\n            # Calculer le volume fictif (bas√© sur le mouvement de prix)\r\n            if len(last_ticks) >= 2:\r\n                price_movement = abs(last_ticks[-1] - last_ticks[-2])\r\n                tick_volume.append(price_movement)\r\n            \r\n            # Mettre √† jour le nombre de ticks par seconde\r\n            count_ticks_per_second()\r\n            \r\n            # Cr√©er des donn√©es OHLC √† partir des ticks\r\n            # Pour simplifier, nous utilisons une approche bas√©e sur les ticks plut√¥t que sur le temps\r\n            if len(ticks_data) == 0 or len(ticks_data) % 5 == 0:  # Cr√©er une nouvelle \"bougie\" tous les 5 ticks\r\n                # Ajouter les donn√©es aux listes\r\n                ticks_data.append(price)\r\n                timestamps.append(timestamp)\r\n                \r\n                # Pour simplifier, nous utilisons le m√™me prix pour open, high, low\r\n                # Dans un cas r√©el, on accumulerait les ticks pour former des bougies\r\n                new_row = pd.DataFrame({\r\n                    'time': [timestamp],\r\n                    'open': [price],\r\n                    'high': [price],\r\n                    'low': [price],\r\n                    'close': [price],\r\n                    'volume': [1]\r\n                })\r\n                \r\n                # Mettre √† jour le DataFrame\r\n                df = pd.concat([df, new_row], ignore_index=True)\r\n            else:\r\n                # Mettre √† jour la derni√®re \"bougie\"\r\n                ticks_data.append(price)\r\n                \r\n                # Mettre √† jour les valeurs high, low, close\r\n                df.at[len(df)-1, 'high'] = max(df.iloc[-1]['high'], price)\r\n                df.at[len(df)-1, 'low'] = min(df.iloc[-1]['low'], price)\r\n                df.at[len(df)-1, 'close'] = price\r\n                df.at[len(df)-1, 'volume'] += 1\r\n            \r\n            # Limiter la taille du DataFrame pour les performances\r\n            if len(df) > RSI_PERIOD * 3:\r\n                df = df.iloc[-RSI_PERIOD*3:]\r\n            \r\n            # Calculer les indicateurs\r\n            if len(df) > RSI_PERIOD:\r\n                df = calculate_indicators(df)\r\n                \r\n                # Ex√©cuter la strat√©gie\r\n                strategy_message = execute_strategy(df)\r\n                if \"TRADE EX√âCUT√â\" in strategy_message:\r\n                    print(\"=\" * 50)\r\n                    print(strategy_message)\r\n                    print(\"=\" * 50)\r\n        \r\n        # Traitement des informations du compte\r\n        elif \"authorize\" in response and response[\"authorize\"]:\r\n            account_info = response[\"authorize\"]\r\n            account_balance = account_info[\"balance\"]\r\n            account_currency = account_info[\"currency\"]\r\n            \r\n            print(\"=\" * 50)\r\n            print(f\"CONNEXION R√âUSSIE | Solde: {account_balance} {account_currency}\")\r\n            print(\"=\" * 50)\r\n            \r\n            # Demander le flux de ticks pour Volatility 100 Index\r\n            subscribe_ticks(ws)\r\n        \r\n        # Traitement des mises √† jour de contrat\r\n        elif \"buy\" in response or \"proposal_open_contract\" in response:\r\n            process_contract_update(response)\r\n        \r\n        # Gestion des erreurs\r\n        elif \"error\" in response:\r\n            print(f\"ERREUR API: {response['error']['message']}\")\r\n    \r\n    except Exception as e:\r\n        print(f\"Erreur lors du traitement du message: {e}\")\r\n\r\ndef on_error(ws, error):\r\n    print(f\"Erreur de connexion: {error}\")\r\n\r\ndef on_close(ws, close_status_code, close_msg):\r\n    print(f\"Connexion ferm√©e: {close_status_code} - {close_msg}\")\r\n    print(\"Tentative de reconnexion dans 5 secondes...\")\r\n    time.sleep(5)\r\n    connect_websocket()\r\n\r\ndef on_open(ws):\r\n    print(\"=\" * 50)\r\n    print(\"CONNEXION WEBSOCKET √âTABLIE\")\r\n    print(\"Bot de trading automatique d√©marr√©\")\r\n    print(\"Volatility 100 Index (1s) - Strat√©gie de Scalping\")\r\n    print(\"=\" * 50)\r\n    \r\n    # Authentification avec le token API\r\n    auth_req = {\r\n        \"authorize\": TOKEN\r\n    }\r\n    ws.send(json.dumps(auth_req))\r\n    print(\"Requ√™te d'authentification envoy√©e\")\r\n\r\ndef subscribe_ticks(ws):\r\n    # S'abonner aux ticks pour Volatility 100 Index\r\n    ticks_request = {\r\n        \"ticks\": SYMBOL,\r\n        \"subscribe\": 1\r\n    }\r\n    ws.send(json.dumps(ticks_request))\r\n    print(f\"Abonnement aux ticks pour {SYMBOL}\")\r\n\r\ndef connect_websocket():\r\n    global ws_global\r\n    # Configuration et d√©marrage du WebSocket\r\n    websocket.enableTrace(False)  # D√©sactiver les traces pour une sortie plus propre\r\n    ws = websocket.WebSocketApp(\r\n        api_url,\r\n        on_open=on_open,\r\n        on_message=on_message,\r\n        on_error=on_error,\r\n        on_close=on_close\r\n    )\r\n    \r\n    ws_global = ws\r\n    \r\n    # Lancer le WebSocket\r\n    ws.run_forever(dispatcher=rel)\r\n    return ws\r\n\r\ndef main():\r\n    global df\r\n    \r\n    # Initialiser le DataFrame avec les colonnes n√©cessaires\r\n    df = pd.DataFrame(columns=['time', 'open', 'high', 'low', 'close', 'volume'])\r\n    \r\n    # Afficher les informations de d√©marrage\r\n    print(\"=\" * 50)\r\n    print(\"D√âMARRAGE DU BOT DE TRADING DERIV\")\r\n    print(f\"Token: {TOKEN[:4]}...{TOKEN[-4:]}\")\r\n    print(f\"Symbole: {SYMBOL}\")\r\n    print(f\"Risque par trade: {RISK_PER_TRADE*100}%\")\r\n    print(f\"Max trades par jour: {MAX_TRADE_COUNT}\")\r\n    print(\"=\" * 50)\r\n    \r\n    # Connecter au WebSocket\r\n    connect_websocket()\r\n    \r\n    # Boucle principale pour maintenir le programme en cours d'ex√©cution\r\n    rel.signal(2, rel.abort)  # Intercepter Ctrl+C\r\n    rel.dispatch()\r\n\r\nif __name__ == \"__main__\":\r\n    try:\r\n        # Variable globale pour stocker la r√©f√©rence WebSocket\r\n        ws_global = None\r\n        \r\n        # D√©marrer le bot\r\n        main()\r\n    except Exception as e:\r\n        print(f\"Erreur dans le programme principal: {e}\")\r\n        \r\n        if missing_packages:\r\n            print(f\"Packages manquants: {', '.join(missing_packages)}\")\r\n            print(\"Veuillez installer les packages manquants avec la commande suivante:\")\r\n            print(f\"pip install {' '.join(missing_packages)}\")\r\n        else:\r\n            # Variable globale pour stocker la r√©f√©rence WebSocket\r\n            ws_global = None\r\n            \r\n            # D√©marrer le bot\r\n            main()\r\n    except Exception as e:\r\n        print(f\"Erreur dans le programme principal: {e}\")",
    "language": "python",
    "description": "Description bot.py",
    "tags": [
      "python"
    ],
    "createdAt": "2025-03-08T15:20:58.992Z",
    "updatedAt": "2025-03-13T17:30:49.435Z"
  },
  {
    "id": "8ad41c44-471d-41f2-a420-3c80a2a5fd1d",
    "title": "webpack.main.config.js",
    "code": "module.exports = {\n  /**\n   * This is the main entry point for your application, it's the first file\n   * that runs in the main process.\n   */\n  entry: './src/main.js',\n  // Put your normal webpack config below here\n  module: {\n    rules: require('./webpack.rules'),\n  },\n};\n",
    "language": "javascript",
    "description": "Description webpack.main.config.js",
    "tags": [
      "jsx"
    ],
    "createdAt": "2025-03-11T11:13:14.186Z",
    "updatedAt": "2025-03-11T11:13:14.189Z"
  },
  {
    "id": "88df16ec-3fc5-4d90-949d-30b320c83d15",
    "title": "forge.config.js",
    "code": "const { FusesPlugin } = require('@electron-forge/plugin-fuses');\nconst { FuseV1Options, FuseVersion } = require('@electron/fuses');\n\nmodule.exports = {\n  packagerConfig: {\n    asar: true,\n  },\n  rebuildConfig: {},\n  makers: [\n    {\n      name: '@electron-forge/maker-squirrel',\n      config: {},\n    },\n    {\n      name: '@electron-forge/maker-zip',\n      platforms: ['darwin'],\n    },\n    {\n      name: '@electron-forge/maker-deb',\n      config: {},\n    },\n    {\n      name: '@electron-forge/maker-rpm',\n      config: {},\n    },\n  ],\n  plugins: [\n    {\n      name: '@electron-forge/plugin-auto-unpack-natives',\n      config: {},\n    },\n    {\n      name: '@electron-forge/plugin-webpack',\n      config: {\n        mainConfig: './webpack.main.config.js',\n        renderer: {\n          config: './webpack.renderer.config.js',\n          entryPoints: [\n            {\n              html: './src/index.html',\n              js: './src/renderer.js',\n              name: 'main_window',\n              preload: {\n                js: './src/preload.js',\n              },\n            },\n          ],\n        },\n      },\n    },\n    // Fuses are used to enable/disable various Electron functionality\n    // at package time, before code signing the application\n    new FusesPlugin({\n      version: FuseVersion.V1,\n      [FuseV1Options.RunAsNode]: false,\n      [FuseV1Options.EnableCookieEncryption]: true,\n      [FuseV1Options.EnableNodeOptionsEnvironmentVariable]: false,\n      [FuseV1Options.EnableNodeCliInspectArguments]: false,\n      [FuseV1Options.EnableEmbeddedAsarIntegrityValidation]: true,\n      [FuseV1Options.OnlyLoadAppFromAsar]: true,\n    }),\n  ],\n};\n",
    "language": "javascript",
    "description": "Description forge.config.js",
    "tags": [
      "jsx",
      "typescrip"
    ],
    "createdAt": "2025-03-11T12:10:06.766Z",
    "updatedAt": "2025-03-13T11:06:27.995Z"
  },
  {
    "id": "87c4a50a-2168-4ae7-b493-1c07aa65c7d5",
    "title": "fragments.json",
    "code": "[\n  {\n    \"title\": \"fullggg\",\n    \"code\": \"No fragments found. Create a new one or adjust your search.\",\n    \"tags\": [\n      \"1741263484490\",\n      \"1741265802245\"\n    ],\n    \"id\": \"1741263346307\"\n  },\n  {\n    \"title\": \"made full\",\n    \"code\": \"import React, { useState, useEffect } from 'react';\\nimport { useParams, useNavigate } from 'react-router-dom';\\nimport Header from '../components/Header';\\nimport DataStore from '../services/dataStore';\\nimport { highlightCode } from '../services/syntaxHighlighter';\\nimport './assets/styles/FragmentFormPage.css'; \\n\\nconst FragmentFormPage = ({ fragments, setFragments, tags, darkMode, toggleDarkMode }) => {\\n  const { id } = useParams();\\n  const navigate = useNavigate();\\n  \\n  const [fragment, setFragment] = useState({\\n    title: '',\\n    code: '',\\n    tags: []\\n  });\\n  \\n  const [isEditing, setIsEditing] = useState(false);\\n  \\n  // Load fragment data if editing an existing one\\n  useEffect(() => {\\n    if (id && id !== 'new') {\\n      const fragmentToEdit = fragments.find(f => f.id === id);\\n      if (fragmentToEdit) {\\n        setFragment(fragmentToEdit);\\n        setIsEditing(true);\\n      } else {\\n        // Fragment not found, redirect to new fragment form\\n        navigate('/fragment/new');\\n      }\\n    }\\n  }, [id, fragments, navigate]);\\n  \\n  const handleInputChange = (e) => {\\n    const { name, value } = e.target;\\n    setFragment(prev => ({\\n      ...prev,\\n      [name]: value\\n    }));\\n  };\\n  \\n  const handleTagChange = (tagId) => {\\n    setFragment(prev => {\\n      const currentTags = prev.tags || [];\\n      \\n      // If tag is already selected, remove it\\n      if (currentTags.includes(tagId)) {\\n        return {\\n          ...prev,\\n          tags: currentTags.filter(id => id !== tagId)\\n        };\\n      }\\n      \\n      // Otherwise, add it\\n      return {\\n        ...prev,\\n        tags: [...currentTags, tagId]\\n      };\\n    });\\n  };\\n  \\n  const handleSubmit = async (e) => {\\n    e.preventDefault();\\n    \\n    if (!fragment.title || !fragment.code) {\\n      alert('Title and code are required!');\\n      return;\\n    }\\n    \\n    try {\\n      const savedFragment = await DataStore.saveFragment(fragment);\\n      \\n      // Update fragments state with new/updated fragment\\n      setFragments(prev => {\\n        if (isEditing) {\\n          return prev.map(f => f.id === savedFragment.id ? savedFragment : f);\\n        } else {\\n          return [...prev, savedFragment];\\n        }\\n      });\\n      \\n      // Redirect to fragments page\\n      navigate('/');\\n    } catch (error) {\\n      console.error('Error saving fragment:', error);\\n      alert('Failed to save fragment. Please try again.');\\n    }\\n  };\\n  \\n  const handleDelete = async () => {\\n    if (!isEditing) return;\\n    \\n    if (window.confirm('Are you sure you want to delete this fragment?')) {\\n      try {\\n        await DataStore.deleteFragment(fragment.id);\\n        \\n        // Update fragments state\\n        setFragments(prev => prev.filter(f => f.id !== fragment.id));\\n        \\n        // Redirect to fragments page\\n        navigate('/');\\n      } catch (error) {\\n        console.error('Error deleting fragment:', error);\\n        alert('Failed to delete fragment. Please try again.');\\n      }\\n    }\\n  };\\n  \\n  return (\\n    <div className=\\\"fragment-form-page\\\">\\n      <Header \\n        toggleDarkMode={toggleDarkMode} \\n        darkMode={darkMode} \\n      />\\n      \\n      <main className=\\\"content\\\">\\n        <div className=\\\"form-container\\\">\\n          <form onSubmit={handleSubmit}>\\n            <div className=\\\"form-group\\\">\\n              <label htmlFor=\\\"title\\\">Title</label>\\n              <input\\n                type=\\\"text\\\"\\n                id=\\\"title\\\"\\n                name=\\\"title\\\"\\n                value={fragment.title}\\n                onChange={handleInputChange}\\n                placeholder=\\\"Enter fragment title\\\"\\n                autoFocus\\n                required\\n              />\\n            </div>\\n            \\n            <div className=\\\"form-group\\\">\\n              <label htmlFor=\\\"code\\\">Code</label>\\n              <textarea\\n                id=\\\"code\\\"\\n                name=\\\"code\\\"\\n                value={fragment.code}\\n                onChange={handleInputChange}\\n                placeholder=\\\"Enter your code here\\\"\\n                rows=\\\"15\\\"\\n                required\\n              />\\n            </div>\\n            \\n            <div className=\\\"form-group\\\">\\n              <label>Tags</label>\\n              <div className=\\\"tags-container\\\">\\n                {tags.map(tag => (\\n                  <div key={tag.id} className=\\\"tag-checkbox\\\">\\n                    <input\\n                      type=\\\"checkbox\\\"\\n                      id={`tag-${tag.id}`}\\n                      checked={fragment.tags && fragment.tags.includes(tag.id)}\\n                      onChange={() => handleTagChange(tag.id)}\\n                    />\\n                    <label htmlFor={`tag-${tag.id}`}>{tag.name}</label>\\n                  </div>\\n                ))}\\n              </div>\\n            </div>\\n            \\n            <div className=\\\"form-actions\\\">\\n              {isEditing && (\\n                <button \\n                  type=\\\"button\\\" \\n                  className=\\\"delete-button\\\"\\n                  onClick={handleDelete}\\n                >\\n                  Delete\\n                </button>\\n              )}\\n              \\n              <button type=\\\"submit\\\" className=\\\"save-button\\\">\\n                Save\\n              </button>\\n            </div>\\n          </form>\\n        </div>\\n        \\n        {fragment.code && (\\n          <div className=\\\"preview-container\\\">\\n            <h3>Preview</h3>\\n            <div className={`code-preview ${darkMode ? 'dark' : 'light'}`}>\\n              <pre>\\n                <code dangerouslySetInnerHTML={{ __html: highlightCode(fragment.code) }} />\\n              </pre>\\n            </div>\\n          </div>\\n        )}\\n      </main>\\n    </div>\\n  );\\n};\\n\\nexport default FragmentFormPage;\",\n    \"tags\": [\n      \"1741263484490\"\n    ],\n    \"id\": \"1741263687376\"\n  },\n  {\n    \"title\": \"mode in \",\n    \"code\": \"import React, { useState, useEffect } from 'react';\\nimport Header from '../components/Header';\\nimport FragmentCard from '../components/FragmentCard';\\nimport CodeModal from '../components/CodeModal';\\nimport './assets/styles/FragmentsPage.css'; \\n\\nconst FragmentsPage = ({ fragments, tags, darkMode, toggleDarkMode }) => {\\n  const [searchTerm, setSearchTerm] = useState('');\\n  const [filteredFragments, setFilteredFragments] = useState([]);\\n  const [selectedFragment, setSelectedFragment] = useState(null);\\n  const [showModal, setShowModal] = useState(false);\\n  \\n  // Update filtered fragments when search term or fragments change\\n  useEffect(() => {\\n    if (!searchTerm.trim()) {\\n      setFilteredFragments(fragments);\\n      return;\\n    }\\n    \\n    const lowerCaseSearch = searchTerm.toLowerCase();\\n    const filtered = fragments.filter(fragment => {\\n      // Search in title\\n      if (fragment.title.toLowerCase().includes(lowerCaseSearch)) {\\n        return true;\\n      }\\n      \\n      // Search in code\\n      if (fragment.code.toLowerCase().includes(lowerCaseSearch)) {\\n        return true;\\n      }\\n      \\n      // Search in tags\\n      if (fragment.tags) {\\n        const fragmentTags = tags.filter(tag => fragment.tags.includes(tag.id));\\n        return fragmentTags.some(tag => \\n          tag.name.toLowerCase().includes(lowerCaseSearch)\\n        );\\n      }\\n      \\n      return false;\\n    });\\n    \\n    setFilteredFragments(filtered);\\n  }, [searchTerm, fragments, tags]);\\n  \\n  const handleViewCode = (fragment) => {\\n    setSelectedFragment(fragment);\\n    setShowModal(true);\\n  };\\n  \\n  const closeModal = () => {\\n    setShowModal(false);\\n  };\\n  \\n  // Handle the drag and drop for creating fragments from files\\n  const handleDrop = (event) => {\\n    event.preventDefault();\\n    \\n    // Get the dropped files\\n    const files = event.dataTransfer.files;\\n    \\n    if (files.length > 0) {\\n      // Read the first file\\n      const reader = new FileReader();\\n      reader.onload = (e) => {\\n        const content = e.target.result;\\n        const fileName = files[0].name;\\n        \\n        // Create a new fragment with the file content\\n        const newFragment = {\\n          title: fileName,\\n          code: content,\\n          tags: []\\n        };\\n        \\n        // Navigate to the fragment form page with this data\\n        // For simplicity we'll just alert here - in a real app you'd use a router\\n        alert(`File detected: ${fileName}\\\\nYou'd be redirected to the fragment form to save this code.`);\\n        console.log('New fragment from file:', newFragment);\\n      };\\n      \\n      reader.readAsText(files[0]);\\n    }\\n  };\\n  \\n  const handleDragOver = (event) => {\\n    event.preventDefault();\\n  };\\n  \\n  return (\\n    <div \\n      className=\\\"fragments-page\\\" \\n      onDrop={handleDrop} \\n      onDragOver={handleDragOver}\\n    >\\n      <Header \\n        toggleDarkMode={toggleDarkMode} \\n        darkMode={darkMode} \\n      />\\n      \\n      <main className=\\\"content\\\">\\n        {/* Search bar */}\\n        <div className=\\\"search-container\\\">\\n          <input\\n            type=\\\"text\\\"\\n            placeholder=\\\"Search fragments...\\\"\\n            value={searchTerm}\\n            onChange={(e) => setSearchTerm(e.target.value)}\\n            className=\\\"search-input\\\"\\n          />\\n        </div>\\n        \\n        {/* Fragments list */}\\n        {filteredFragments.length === 0 ? (\\n          <div className=\\\"no-fragments\\\">\\n            <p>No fragments found. Create a new one or adjust your search.</p>\\n          </div>\\n        ) : (\\n          <div className=\\\"fragments-grid\\\">\\n            {filteredFragments.map(fragment => (\\n              <FragmentCard\\n                key={fragment.id}\\n                fragment={fragment}\\n                tags={tags}\\n                onViewCode={handleViewCode}\\n              />\\n            ))}\\n          </div>\\n        )}\\n      </main>\\n      \\n      {/* Code modal */}\\n      {showModal && (\\n        <CodeModal \\n          fragment={selectedFragment} \\n          onClose={closeModal}\\n          darkMode={darkMode}\\n        />\\n      )}\\n    </div>\\n  );\\n};\\n\\nexport default FragmentsPage;\",\n    \"tags\": [\n      \"1741263484490\"\n    ],\n    \"id\": \"1741265765595\"\n  },\n  {\n    \"title\": \"js\",\n    \"code\": \"import React, { useState, useEffect } from 'react';\\nimport Header from '../components/Header';\\nimport FragmentCard from '../components/FragmentCard';\\nimport CodeModal from '../components/CodeModal';\\nimport './assets/styles/FragmentsPage.css'; \\n\\nconst FragmentsPage = ({ fragments, tags, darkMode, toggleDarkMode }) => {\\n  const [searchTerm, setSearchTerm] = useState('');\\n  const [filteredFragments, setFilteredFragments] = useState([]);\\n  const [selectedFragment, setSelectedFragment] = useState(null);\\n  const [showModal, setShowModal] = useState(false);\\n  \\n  // Update filtered fragments when search term or fragments change\\n  useEffect(() => {\\n    if (!searchTerm.trim()) {\\n      setFilteredFragments(fragments);\\n      return;\\n    }\\n    \\n    const lowerCaseSearch = searchTerm.toLowerCase();\\n    const filtered = fragments.filter(fragment => {\\n      // Search in title\\n      if (fragment.title.toLowerCase().includes(lowerCaseSearch)) {\\n        return true;\\n      }\\n      \\n      // Search in code\\n      if (fragment.code.toLowerCase().includes(lowerCaseSearch)) {\\n        return true;\\n      }\\n      \\n      // Search in tags\\n      if (fragment.tags) {\\n        const fragmentTags = tags.filter(tag => fragment.tags.includes(tag.id));\\n        return fragmentTags.some(tag => \\n          tag.name.toLowerCase().includes(lowerCaseSearch)\\n        );\\n      }\\n      \\n      return false;\\n    });\\n    \\n    setFilteredFragments(filtered);\\n  }, [searchTerm, fragments, tags]);\\n  \\n  const handleViewCode = (fragment) => {\\n    setSelectedFragment(fragment);\\n    setShowModal(true);\\n  };\\n  \\n  const closeModal = () => {\\n    setShowModal(false);\\n  };\\n  \\n  // Handle the drag and drop for creating fragments from files\\n  const handleDrop = (event) => {\\n    event.preventDefault();\\n    \\n    // Get the dropped files\\n    const files = event.dataTransfer.files;\\n    \\n    if (files.length > 0) {\\n      // Read the first file\\n      const reader = new FileReader();\\n      reader.onload = (e) => {\\n        const content = e.target.result;\\n        const fileName = files[0].name;\\n        \\n        // Create a new fragment with the file content\\n        const newFragment = {\\n          title: fileName,\\n          code: content,\\n          tags: []\\n        };\\n        \\n        // Navigate to the fragment form page with this data\\n        // For simplicity we'll just alert here - in a real app you'd use a router\\n        alert(`File detected: ${fileName}\\\\nYou'd be redirected to the fragment form to save this code.`);\\n        console.log('New fragment from file:', newFragment);\\n      };\\n      \\n      reader.readAsText(files[0]);\\n    }\\n  };\\n  \\n  const handleDragOver = (event) => {\\n    event.preventDefault();\\n  };\\n  \\n  return (\\n    <div \\n      className=\\\"fragments-page\\\" \\n      onDrop={handleDrop} \\n      onDragOver={handleDragOver}\\n    >\\n      <Header \\n        toggleDarkMode={toggleDarkMode} \\n        darkMode={darkMode} \\n      />\\n      \\n      <main className=\\\"content\\\">\\n        {/* Search bar */}\\n        <div className=\\\"search-container\\\">\\n          <input\\n            type=\\\"text\\\"\\n            placeholder=\\\"Search fragments...\\\"\\n            value={searchTerm}\\n            onChange={(e) => setSearchTerm(e.target.value)}\\n            className=\\\"search-input\\\"\\n          />\\n        </div>\\n        \\n        {/* Fragments list */}\\n        {filteredFragments.length === 0 ? (\\n          <div className=\\\"no-fragments\\\">\\n            <p>No fragments found. Create a new one or adjust your search.</p>\\n          </div>\\n        ) : (\\n          <div className=\\\"fragments-grid\\\">\\n            {filteredFragments.map(fragment => (\\n              <FragmentCard\\n                key={fragment.id}\\n                fragment={fragment}\\n                tags={tags}\\n                onViewCode={handleViewCode}\\n              />\\n            ))}\\n          </div>\\n        )}\\n      </main>\\n      \\n      {/* Code modal */}\\n      {showModal && (\\n        <CodeModal \\n          fragment={selectedFragment} \\n          onClose={closeModal}\\n          darkMode={darkMode}\\n        />\\n      )}\\n    </div>\\n  );\\n};\\n\\nexport default FragmentsPage;\",\n    \"tags\": [\n      \"1741263484490\",\n      \"1741265802245\"\n    ],\n    \"id\": \"1741265787521\"\n  }\n]",
    "language": "json",
    "description": "Description fragments.json",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-13T16:54:20.079Z",
    "updatedAt": "2025-03-13T16:54:20.082Z"
  },
  {
    "id": "a8347eb0-657d-46d4-aac0-015eb18c1288",
    "title": "package.json",
    "code": "{\n  \"main\": \"public/electron.js\",\n  \"homepage\": \"./\",\n  \"scripts\": {\n    \"start\": \"concurrently \\\"cross-env BROWSER=none react-scripts start\\\" \\\"wait-on http://localhost:3000 && electron .\\\"\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\",\n    \"lint\": \"eslint .\",\n    \"react-only\": \"react-scripts start\",\n    \"electron:build\": \"npm run build && electron-builder -c.extraMetadata.main=build/electron.js\",\n    \"package\": \"electron-builder build --win --publish never\"\n  },\n  \"dependencies\": {\n    \"cross-env\": \"^7.0.3\",\n    \"electron\": \"^24.0.0\",\n    \"highlight.js\": \"^11.8.0\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.15.0\",\n    \"wait-on\": \"^5.3.0\"\n  },\n  \"devDependencies\": {\n    \"concurrently\": \"^7.0.0\",\n    \"electron-builder\": \"^24.0.0\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-plugin-react\": \"^7.33.2\",\n    \"react-scripts\": \"^5.0.0\"\n  },\n  \"build\": {\n    \"appId\": \"com.everydaydev.codewallet\",\n    \"productName\": \"Code Wallet\",\n    \"files\": [\n      \"build/**/*\",\n      \"node_modules/**/*\",\n      \"public/preload.js\"\n    ],\n    \"directories\": {\n      \"buildResources\": \"assets\"\n    }\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}",
    "language": "json",
    "description": "Description package.json",
    "tags": [
      "Js"
    ],
    "createdAt": "2025-03-13T16:59:29.648Z",
    "updatedAt": "2025-03-13T16:59:29.648Z"
  }
]